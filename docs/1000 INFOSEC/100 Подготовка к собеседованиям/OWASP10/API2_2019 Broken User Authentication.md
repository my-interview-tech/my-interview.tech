---
title: API2-2019 Broken User Authentication
draft: true
tags:
  - infosec
  - OWASP
info:
---

**API2:2019 — Broken User Authentication** (Некорректная аутентификации пользователей)

«_Механизмы аутентификации часто реализуются некорректно, что позволяет злоумышленникам скомпрометировать токены аутентификации или использовать недостатки реализации для временного или постоянного присвоения идентификаторов других пользователей. Компрометация способности системы идентифицировать клиента / пользователя ставит под угрозу безопасность API в целом_».

Распространенной уязвимостью API является использование нелегитимных токенов для получения доступа к endpoints. Сами системы аутентификации могут быть скомпрометированы или случайно раскрыть API Key. Токены аутентификации для получения доступа могут использовать злоумышленники.

Примеры сценариев атак:

1) Перебор учетных данных с использованием списка известных логинов и паролей. Если в приложении отсутствуют автоматизированные меры защиты от угроз или перебора учетных данных, то оно может быть использовано для определения валидности учетных данных.

2) Злоумышленник начинает восстановление пароля, отправив POST запрос в точку входа `/api/system/verification-codes` и указав имя пользователя в теле запроса. Затем одноразовый пароль из 6 цифр отправляется на телефон жертвы. Поскольку API не ограничивает количество запросов, злоумышленник может за несколько минут подобрать корректный одноразовый пароль, перебирая все возможные пароли с помощью скрипта, работающего в многопоточном режиме и отправляющего запросы на `/api/system/verification-codes/{smsToken}`

Основные варианты аутентификации (в порядке увеличения их безопасности):

_API Key_ — это строка символов, которую передает клиент в запросах к серверу. Для успешной аутентификации строка должна совпадать у клиента и у сервера. Данная схема обеспечивает защиту от несанкционированного использования API и позволяет осуществлять, например, проверку лимитов использования API.

В _Basic Authentication_ используется аутентификация по двум строкам, например логину/паролю. Для передачи информации используется HTTP заголовок Authorization с ключевым словом Basic далее пробел и закодированная в base64 строка username:password.

_Cookie-Based Authentication_ использует механизм передачи Cookies в HTTP запросах. В ответ на запрос клиента сервер посылает заголовок Set-Cookie, который содержит имя и значение cookie, а также дополнительные атрибуты: expires, domain, path, secure, httponly, samesite.

_Token-Based Authentication_ также называют _Bearer Authentication_ использует подписанный сервером токен (bearer token), который клиент передает на сервер в HTTP-заголовке Authorization с ключевым словом Bearer или в теле запроса. При получении токена сервер должен проверять его на валидность: что пользователь существует, время использования не прошло и т.д.

При любом способе аутентификации для безопасного использования должен использоваться HTTPS, который обеспечивает шифрование данных, заголовков и URL. Плюсы Token-Based:

- нет необходимости хранить пароли в базе данных на сервере.

- можно получать информацию о пользователях от сервера авторизации через claims и scopes.

- нет проблем с безопасностью, характерных для остальных методов:

- при компрометации логина/пароля доступ к данным получается сразу и длится пока пользователь сам не заметит факт взлома, у токенов же есть время жизни, которое ограничивается разумными значениями: например, 5 минут для access token и час для refresh token;

- токен автоматически не уйдет на сторонний сайт, как cookie.

- можно не хранить сессию пользователя на сервере, а токен проверять каждый раз.

Рекомендации:

- идентифицируйте все возможные способы аутентификации в API (для мобильных и веб клиентов, deep links, обеспечивающих аутентификацию в одно нажатие, и т.д.).

- не используйте API Key и базовую аутентификацию для пользователей. Они предназначены для аутентификации приложений и систем, являющихся клиентами API. Если это доступ из одной системы в другую, рассмотрите возможность добавления дополнительных уровней безопасности, таких как mTLS с контролем клиентского сертификата (pinning) и белый список отправителей токенов.

- проверяйте redirect_uri на стороне сервера, чтобы разрешать uri только из белого списка.

- используйте код (Authorization Code), а не токены (Implicit Grant), т.е. не разрешайте response_type=token.

- используйте OIDC.

 - используйте параметры state и nonce со случайным хешем, чтобы предотвратить CSRF в процессе аутентификации OAuth.

- определите scope по умолчанию и проверяйте его параметры для каждого приложения.

- используйте механизмы защиты от перебора учетных данных, перебора по словарю и перебора всех возможных значений на точках входа, отвечающих за аутентификацию + на точках входа, отвечающих за восстановление учетных данных и пароля — ограничение на количество единовременных запросов и временную блокировку учетных записей. Эти механизмы должны использовать более строгие правила по сравнению с механизмом ограничивающим количество запросов в остальных точках входа API.

- внедрите блокировку учетных записей или CAPTCHA для предотвращения перебора аутентификационных данных, направленного на единичных пользователей. Внедрите защиту от слабых паролей.
____
