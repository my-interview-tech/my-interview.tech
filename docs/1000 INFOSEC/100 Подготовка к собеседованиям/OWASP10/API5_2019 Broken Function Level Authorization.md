---
title: API5-2019 Broken Function Level Authorization
draft: true
tags:
  - infosec
  - OWASP
info:
---

**API5:2019 Broken Function Level Authorization** (Некорректная авторизация на уровне функций) «_Сложные политики контроля доступа с иерархиями, группами и ролями, а также нечеткое разделение административных и обычных привилегий, как правило, приводят к проблемам с авторизацией. Эксплуатируя их, злоумышленники получают доступ к ресурсам и/или административным полномочиям других пользователей_».

Как определить, является ли API уязвимым?

Лучший способ найти проблемы с некорректной авторизацией на уровне функций - провести глубокий анализ механизма авторизации, учитывая иерархию пользователей, различные роли и группы внутри приложения, а также задав себе следующие вопросы:

- Может ли обычный пользователь получить доступ к административным точкам входа?

- Может ли пользователь совершить критичные действия (например, создать, изменить или удалить объект), к которым у него не должно быть доступа, просто изменив метод HTTP запроса (например, с GET на DELETE)?

- Может ли пользователь из группы Х получить доступ к точке входа, доступной только пользователям из группы Y, просто угадав URL и параметры этой точки входа (например, `/api/v1/users/export_all`)?

Наивно предполагать, что точка входа API является обычной или административной только на основании пути URL.

Зачастую разработчики открывают доступ к административным точкам входа по определенному относительному пути, например, `api/admins`. Однако очень часто административные точки входа находятся по другим относительным путям вместе с обычными точками входа, например, api/users.

Примеры сценариев атаки:

1) В ходе процесса регистрации в приложении, которое позволяет регистрироваться только приглашенным пользователям, мобильное приложение отправляет следующий запрос к API GET /api/invites/{invite_guid}. Ответ содержит JSON с деталями приглашения, включая роль пользователя и его электронную почту.

Злоумышленник может дублировать запрос, изменив HTTP метод и точку входа на POST `/api/invites/new`. Только администраторы должны иметь доступ к этой точке входа через интерфейс администрирования, однако он не проводит проверки авторизации на уровне функций. Проэксплуатировав уязвимость, злоумышленник может отправить себе приглашение с ролью администратора:

`POST /api/invites/new`

`{“email”:”hugo@malicious.com”,”role”:”admin”}`

2) API содержит точку входа, которая должна быть доступна только администраторам GET `/api/admin/v1/users/all`. Эта точка входа возвращает данные всех пользователей и не проводит проверки авторизации на уровне функции. Злоумышленник, изучив структуру API, подбирает URL и получает доступ к точке входа, которая возвращает критичные данные пользователей приложения.

Как предотвратить:

- В приложении должен быть согласованный и легко анализируемый модуль авторизации, вызываемый всеми бизнес функциями. Зачастую такая защита предоставляется одной или несколькими компонентами вне кода приложения.

- Механизм, обеспечивающий выполнение проверок авторизации, должен запрещать весь доступ по умолчанию и требовать наличия определенных ролей для доступа к каждой из функций.

- Проверьте все точки входа API на предмет некорректной авторизации на уровне функций, принимая во внимание бизнес логику приложения и иерархию групп.

- Убедитесь, что все административные контроллеры наследуют абстрактный административный контроллер, в котором реализованы проверки авторизации на базе пользовательских групп и ролей.

- Убедитесь, что административные функции внутри обычных контроллеров проводят проверки авторизации на базе пользовательских групп и ролей.

- Должна быть разработана четкая система разграничения доступа между ролями пользователей API. Например, если есть роли: пользователи и администраторы, то команду по просмотру всех пользователей может вызвать только администратор: GET /users/all

При каждом вызове команды необходима проверка прав доступа, чтобы обычный пользователь не мог вызвать команду, изменив только ее формат.

Чтобы уменьшить эту уязвимость применяются scopes/claims и стандарт OpenID Connect. Они вводят дополнительные ограничения для пользователя, связывая его с запрашивающей стороной. Кроме того, claims упрощают реализацию API: токен содержит множество данных, но API достаточно посмотреть, разрешено ли, например, пользователю Алисе выполнить действие 1.

___
