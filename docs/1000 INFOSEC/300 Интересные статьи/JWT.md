---
title: JWT
draft: true
tags:
  - infosec
  - JWT
  - base64
info:
---

JWT - это структуры данных в формате JSON, содержащие набор утверждений (claims), которые можно использовать для принятия решений по управлению доступом. Токен представляет собой длинную строку, разделенную на части точками, каждая часть которой закодирована в base64. Состав токена зависит от его типа: JWS (signed) или JWE (encrypted). В JWS есть 3 раздела: заголовок, полезные данные и подпись. JWE состоит из 5 частей: заголовка, зашифрованного ключа, вектора инициализации, зашифрованного текста (полезной нагрузки) и тега аутентификации. JWT содержат данные (by-value). API должен декодировать и проверять токен. Если вы используете JWT в качестве токенов доступа, необходимо помнить, что все желающие смогут получить доступ к его данным. Access tokens чаще всего используются в качестве токенов на предъявителя (bearer). Если это может создать проблемы, можно изменить его тип на Proof of Possession (PoP), добавив claim cnf - требование подтверждения. Этот сlaim может содержать fingerprint сертификата клиента, который проверяется сервером ресурсов.

Независимо от типа (JWS или JWE) токен содержит claim alg в заголовке, которое указывает, какой алгоритм используется для подписи или шифрования. Необходимо каждый раз проверять значение этого утверждения с помощью белого списка. Это смягчает вектор атаки, когда кто-то может изменить токен, чтобы заставить использовать другой, менее стойкий алгоритм для проверки подписи или шифрования. Белый список алгоритмов предпочтительнее черного, т. к. были атаки на API, которые использовали тот факт, что alg noNe интерпретировался как none, но не был исключен из черного списка. Незащищенные токены {"alg":"none"} не допускаются. В настоящее время наиболее рекомендуемым алгоритмом является ES256 (подпись с эллиптической кривой (ECDSA) с P-256), хотя по-прежнему наиболее популярен RS256 (RSASSA-PKCS1). Первый намного быстрее второго, который появился раньше, поэтому поддерживается большим количеством разработчиков. Тем не менее, если система позволяет, и вы уверены, что клиенты его поддерживают, следует выбрать ES256. Если требуется использовать симметричные алгоритмы, то следует выбрать HS256 (HMAC), но он не рекомендуется из-за отсутствия аутентификации сторон и рисков передачи общего ключа.

Основное правило — всегда проверять входящий JWT, даже во внутренней сети, где сервер авторизации, клиент и сервер ресурсов не подключены к Интернет. Особенно, если используется implicit flow, и токен отправляется обратно клиенту с помощью redirect URI, т.к. в этом случае существует риск того, что кто-то подделает токен, прежде чем он будет получен адресатом.

Некоторые claims стандартизированы и должны присутствовать в JWT, используемом для контроля доступа. По крайней мере должны быть проверены следующие стандартные claims:

iss - _эмитент_ - если токен содержит утверждение iss, то необходимо подтверждение того, что криптографические ключи, используемые для подписи или шифрования токена, действительно принадлежат этому эмитенту. Эмитентом должен быть URL, использующий https. Также помните, что значение iss должно соответствовать ожидаемому буквально, т.е. если вы ожидаете, что эмитент будет https://example.com, то это не то же самое, что https://example.com/secure.

aud - _аудитория_ - сервер ресурсов всегда должен проверять утверждение aud в токене и сопоставлять его с белым списком. Любые запросы, содержащие токены, предназначенные для чужой аудитории отклоняются. Это помогает смягчить риск, когда сервер ресурсов получает подлинный токен доступа, предназначенный для него, а затем использует его для получения доступа к ресурсам на другом сервере, который ему недоступен. ID token должен содержать в aud идентификатор клиента. Этот токен не следует передавать кому-либо еще. Для Access Token рекомендуется использовать URL-адрес API, для которого он предназначен. При проверке JWT всегда убеждайтесь, что они используются по назначению. Например, что вы не примете ID-токен в качестве токена доступа. Этого можно добиться разными способами, в зависимости от реализации, например, заметив, что у ID-токена нет scope.

JWT — автономные токены на предъявителя, поэтому их очень сложно отозвать после выпуска и доставки. Из-за этого приходится применять как можно более короткий срок действия токенов: 3-15 минут для AT, для RT — не более часа.

exp - _срок действия_, содержащий время истечения срока, не единственный временной claim, который можно использовать для проверки. В nbf указано время «не раньше». Если текущее время раньше nbf, токен должен быть отклонен. Другой claim времени - iat - время выпуска. Можно использовать это утверждение, чтобы отклонять явно устаревшие токены.

При работе с такими claims помните, что время сервера может немного отличаться на разных машинах. При проверке значений времени следует учесть возможность рассинхронизации на несколько секунд (не более 30), т.к. большее значение, скорее, указывает на проблемы с сервером, а не на рассинхронизацию.

В случае подписанного JWT (JWS) надо помнить, что подписывается не только полезная нагрузка, но и заголовок токена. Любое изменение заголовка или полезной нагрузки приведет к необходимости другой подписи. Для смягчения риска, когда два токена будут созданы с одинаковой подписью (т.е. два токена созданы в ту же секунду, для одного и того же клиента и пользователя, с одинаковой областью действия и т. д.) сервер авторизации добавляет в claim jti случайный идентификатор токена. Благодаря этому можно быть уверенным, что у двух разных токенов никогда не будет одинаковой подписи. Для подписей требуются ключи или сертификаты, которые должны быть правильно проверены. Эти ключи или сертификаты можно получить с сервера авторизации несколькими способами. Вы можете, например, получить ключи в начале работы и убедиться, что сервер ресурсов имеет доступ к этим ключам. Однако это создает проблему при изменении ключей или сертификатов. Вот почему рекомендуется пользоваться endpoints и динамически загружать ключи или сертификаты с сервера авторизации. Это позволяет упростить ротацию ключей. Если ключи или сертификаты отправляются в заголовке JWT, необходимо сравнивать их с белым списком ключей или проверять цепочку доверия в случае сертификатов. Когда происходит завершение сеанса, хэши связанных JWT должны быть отправлены в черный список, который аннулирует этот JWT до истечения срока действия токена.

Стандарт OpenID Connect вводит попарно псевдонимные идентификаторы (PPID), которые можно использовать вместо обычного идентификатора пользователя. PPID — это скрытый идентификатор пользователя, уникальный для данного клиента. Он помогает повысить конфиденциальность пользователей. Особенно, если используются конфиденциальные данные в качестве идентификатора пользователя, например электронная почта или телефон. Благодаря PPID клиент по-прежнему может идентифицировать пользователя, но не получит лишней информации.

Растет число разработчиков, которые утверждают, что JWT имеют некоторые преимущества для использования в качестве механизма хранения сессий вместо cookie и SSO. Это не так. JWT никогда не рассматривались для использования с сессиями, и использование их таким образом фактически может снизить безопасность приложений. Важно помнить, что безопасность JWT во многом зависит от того, как они реализованы и используются. Тот факт, что JWT содержит криптографическую подпись, автоматически не означает, что он безопасен или что мы должны ему слепо доверять. Стандарты безопасности и уровни безопасности криптографии могут меняться довольно быстро, поэтому необходимо следить за тем, что происходит в отрасли.

___

