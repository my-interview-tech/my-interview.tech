---
title: REST API Security
draft: true
tags:
  - infosec
  - OWASP
info:
  - https://cheatsheetseries.owasp.org/cheatsheets/REST_Security_Cheat_Sheet.html
---

**API Key**

Общедоступные REST-сервисы без контроля доступа подвержены атакам типа «отказ в обслуживании». Для снижения этого риска применяются API key. Они часто используются для монетизации API: вместо блокировки высокочастотных вызовов клиентам предоставляется доступ на то количество запросов, которое они оплатили. Однако, ключи относительно легко скомпрометировать, поэтому:

- требуйте API-ключ в ответ на каждый запрос к защищенной конечной точке;
- возвращайте код ответа http “429 Too Many Requests", если запросы поступают слишком часто;
- отзывайте API-ключ, если клиент нарушает соглашение об использовании;
- не полагайтесь исключительно на API ключи для защиты конфиденциальных, критических или ценных данных.

**Ограничение допустимых методов HTTP**

- создайте белый список разрешенных методов, например, GET (чтение), POST (создание), PUT / PATCH (замена / обновление) и DELETE (для удаления записи):

 Access-Control-Allow-Methods: GET, POST, PUT

- отклоняйте все запросы, не соответствующие белому списку с HTTP-кодом ответа “405 Method not allowed“.
- убедитесь, что вызывающая сторона имеет право использовать входящий HTTP-метод.

**Форматно-логический контроль поступающих данных (валидация)**

- Проверяйте на корректность длину, диапазон, формат и тип данных ([https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/Input_Validation_Cheat_Sheet.html)).

- Проводите неявную проверку входных данных, используя строгие типы (числа, логические значения, даты, время или фиксированные диапазоны данных) в параметрах API.
- Ограничивайте ввод строк с помощью регулярных выражений.
- Отклоняйте непредусмотренный / недопустимый контент.
- Используйте проверочные библиотеки (e.g. libxml2) или sanitizer’ы.
- Определите предельный размер запроса и отклоняйте запросы, его превышающие, со статусом ответа HTTP “413 Request Entity Too Large“.
- Используйте безопасный парсер для анализа входящих XML-сообщений, который неуязвим для XXE и подобных атак ([https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html](https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html)).

**Проверка типа контента в теле запроса или ответа**

Тело запроса или ответа должно соответствовать предполагаемому типу содержимого в заголовке (например: application/x-www-form-urlencoded, multipart/form-data, application/json и т.д.). В противном случае это может привести к неправильной интерпретации на стороне потребителя / поставщика и привести к внедрению / выполнению кода. Документируйте все поддерживаемые типы контента в API.

**Проверка типа контента в запросе**

Отклоняйте запросы, содержащие непредусмотренные или отсутствующие заголовки с типом контента, отвечая HTTP- статусом “406 Unacceptable“ или “415 Unsupported Media Type“. Для XML обеспечьте надлежащую защиту парсера (см. выше).

Избегайте случайного раскрытия ожидаемых типов контента, явно их определяя. Это позволяет избежать XXE-атак.

**Безопасные типы контента в ответах**

Службы REST допускают использование нескольких типов ответов (например, application/xml или application/json), и клиент указывает предпочтительные с помощью заголовка Accept в запросе. НЕ копируйте заголовок Accept в заголовок Content-type ответа. Отклоните запрос, ответив “406 Unacceptable“, если заголовок Accept не конкретизирует один из допустимых типов. Убедитесь, что в вашем ответе отправлены заголовки ожидаемого типа контента, например, application/JSON, а не application/Javascript.

**Endpoints**

Если конечные точки должны быть доступны через Интернет, убедитесь, что пользователи всегда используют механизм строгой аутентификации, например, многофакторной.

Предоставляйте конечные точки управления через разные HTTP-порты или хосты, предпочтительно через другой сетевой интерфейс и в ограниченной подсети.

Ограничьте доступ к этим конечным точкам правилами брандмауэра и использованием списков контроля доступа.

**Обработка ошибок**

Отвечая по ошибкам избегайте избыточной информации.

Не передавайте технические подробности (например, используемые стеки, версии компонентов или другие детали), которые могут помочь злоумышленникам, например, X-Powered-By, Server, X-AspNet-Version — подсказки, позволяющие определить какой сервер используется. Для усложнения поиска уязвимостей передачу этих заголовков необходимо запретить.

**CORS**

Cross-Origin Resource Sharing (CORS) - это стандарт W3C, позволяющий гибко настраивать, какие междоменные запросы разрешены. Предоставляя соответствующие заголовки CORS, REST API сигнализируют браузеру, какие домены (источники), могут выполнять вызовы JavaScript для REST-сервисов. Отключите CORS, если междоменные вызовы не используются. Будьте внимательны при настройке источников междоменных вызовов.

Например, если на сервере установить заголовок:

Access-Control-Allow-Origin: *

то это позволит использовать API без ограничения. Если это непубличный API, то для безопасности надо явно устанавливать Origin, с которых разрешен доступ к API, например:

Access-Control-Allow-Origin: https://example.com:8080

Также можно ограничивать HTTP методы, которые могут быть использованы для доступа к API: Access-Control-Allow-Methods: GET, POST, DELETE, PUT

И задать список заголовков, которые сервер может принимать:

Access-Control-Allow-Headers: Origin, Content-Type, Authorization

**Конфиденциальная информация в HTTP-запросах**

Пароли, токены, API Key не должны отображаться в URL, так как могут попасть в журнал веб-сервера. Для этого используется стандартный HTTP-заголовок Authorization

В запросах POST / PUT конфиденциальные данные должны передаваться в теле запроса или заголовках запроса.

В GET-запросах конфиденциальные данные должны передаваться в HTTP-заголовке.

Например таким образом:

https://example.com/resourceCollection/[ID]/action

https://twitter.com/vanderaj/lists

Но не таким:

https://example.com/controller/123/action?apiKey=a53f435643de32,

поскольку здесь ключ API явно указан в URL.

**HTTP-коды состояния**

При разработке REST API кодов состояния 200 и 404 явно недостаточно. Выбирайте семантически правильный код состояния для ответа в зависимости от ситуации, например:

|**Код**|**Сообщение**|**Описание**|
|---|---|---|
|200|OK|Ответ на успешное действие REST API. Метод HTTP может быть GET, POST, PUT, PATCH или DELETE.|
|201|Created|Запрос выполнен, ресурс создан. URI для созданного ресурса возвращается в заголовке Location.|
|202|Accepted|Запрос принят в обработку, но обработка еще не завершена.|
|301|Moved Permanently|Постоянное перенаправление.|
|304|Not Modified|Ответ, который возвращается, когда у клиента есть та же копия ресурса, что и у сервера.|
|307|Temporary Redirect|Временное перенаправление ресурса.|
|400|Bad Request|Запрос имеет неправильный формат, например ошибку в формате тела сообщения.|
|401|Unauthorized|Указан неверный (или отсутствует) идентификатор / пароль|
|402|Request Failed|Транзакция отклонена. Параметры действительны, но запрос не выполнен.|
|403|Forbidden|Используется, когда аутентификация прошла успешно, но у пользователя нет разрешения на запрошенный ресурс.|
|404|Not Found|Запрашивается несуществующий ресурс.|
|405|Method Not Acceptable|Ошибка непредвиденного метода HTTP. Например, REST API ожидает HTTP GET, а используется HTTP PUT.|
|406|Unacceptable|Клиент представил в заголовке Accept тип контента, который не поддерживается серверным API.|
|409|Conflict|Конфликт ресурсов — может быть вызван выполнением запроса, например попыткой создания дублирующего запроса на передачу с использованием того же идентификатора ссылки на транзакцию, что и в предыдущем запросе на передачу.|
|413|Payload too large|Используется, чтобы сигнализировать, что размер запроса превышает заданный лимит, например, в отношении загрузки файлов.|
|415|Unsupported Media Type|Запрошенный тип содержимого не поддерживается REST-сервисом.|
|429|Too Many Requests|Используется для отклонения запроса и ограничения возможности проведения DoS-атак.|
|500|Internal Server Error|Неизвестная ошибка не позволила серверу выполнить запрос. Ответ на нее не должен раскрывать внутреннюю информацию об используемых технологиях, которая может помочь злоумышленнику.|
|501|Not Implemented|REST-сервис не готов выполнить запрошенную операцию.|
|503|Service Unavailable|REST-сервис временно не может обработать запрос. Используется для информирования клиента о необходимости повторить попытку позже.|

Полный список hhtp-кодов состояния: https://www.restapitutorial.com/httpstatuscodes.html.

**Безопасные** **HTTP-заголовки** (https://owasp.org/www-project-secure-headers/)

Проверить можно на https://securityheaders.com/

Защита от атак межсайтовых скриптов:

X-XSS-Protection "1; mode=block"

Защита от Clickjacking:

X-Frame-Options “DENY”

или разрешить только в нашем домене: X-Frame-Options: sameorigin

а также Content-Security-Policy: frame-ancestors 'none'

Защита от рисков подмены типа данных:

X-Content-Type-Options nosniff

Предотвращение атак XSS, clickjacking, иньекции кода:

Content-Security-Policy: script-src 'self', default-src 'none', 'report-uri https://foo.example/report;'

Запрет трекинга URL:

Referrer-Policy "no-referrer"

Запрет применения html-фич для API:

Feature-Policy: 'none'

Запрет соединений, незащищенных TLS, чтобы избежать атаки SSL Strip:

HTTP Strict Transport Security 'max-age=86400; includeSubDomains' где 86400 — сутки в секундах

Запрет кэширования для чувствительной информации (пароли, ключи, токены...):

Cache-Control: no-store

Certificate Transparency – подтверждение того, что сервер получил сертификат через публично журналируемый УЦ, запись о выдаче данного сертификата есть и доступна по url:

Expect-CT: max-age=86400, enforce, report-uri="https://foo.example/report"

**Атрибуты кук**

Set-Cookie Secure=True; HttpOnly=True, SameSite=strict, где

secure - браузер будет отправлять cookies только по HTTPS протоколу.

httpOnly - браузер не будет отправлять cookies при запросах из JavaScript, что предотвратит атаки cross-site scripting (XSS).

SameSite - браузер будет отправлять cookies только тому сайту, который их установил.

В соответствии с европейской директивой GDPR необходимо явно запросить у пользователя разрешение о применении cookies: https://www.privacypolicies.com/blog/eu-cookies-directive/

Общие правила безопасности для Cookies и Local Storage:

- нельзя хранить важную информацию с сервера, т.к. она доступна пользователю.

- нельзя хранить ПДн пользователя, т.к. они могут стать доступными другим пользователям.

- можно хранить только зашифрованные данные или служебную информацию.

**Предотвращение кэширования чувствительных данных** (пароли, ключи, токены и т.п.):

Cache-Control: no-cache, no-store, must-revalidate

Pragma: no-cache

Expires: 0

**TLS**

REST-сервисы должны предоставлять endpoint только в http**s**. Это защищает учетные данные аутентификации при передаче (пароли, ключи API или JWT). Это также позволяет клиентам аутентифицировать сервис и гарантирует целостность передаваемых данных. Для обеспечения защиты используется взаимная аутентификация клиентского и серверного сертификатов по протоколу TLS 1.3 (RFC 8446) с шифронаборами:

TLS_AES_128_GCM_SHA256 (0x13, 0x01)

TLS_AES_256_GCM_SHA384 (0x13, 0x02)

TLS_CHACHA20_POLY1305_SHA256 (0x13, 0x03)

TLS_AES_128_CCM_SHA256 (0x13, 0x04)

TLS_AES_128_CCM_8_SHA256 (0x13, 0x05)

Для версий TLS ниже 1.3 рекомендованы только следующие 4 шифронабора:

TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 (0xC0, 0x2F)

TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 (0xC0, 0x30)

TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 (0x00, 0x9E)

TLS_DHE_RSA_WITH_AES_256_GCM_SHA384 (0x00, 0x9F).

Длины ключей должны быть не менее 160 бит для алгоритмов на основе эллиптических кривых (ECDHE), и не менее 2048 бит для алгоритмов на основе RSA (NIST.SP.800-52r2).

Проверка статуса отзыва сертификата (OCSP) проводится в соответствии с RFC 8954.

**TLS по ГОСТ**

C 1 июня 2020 года действуют Рекомендации по стандартизации Р 1323565.1.030-2018 «Информационная технология. Криптографическая защита информации. Использование российских криптографических алгоритмов в протоколе безопасности транспортного уровня (TLS 1.3)» (https://tools.ietf.org/html/draft-smyshlyaev-tls13-gost-suites-02). Шифронаборы:

 TLS_GOSTR341112_256_WITH_KUZNYECHIK_MGM_L (0xC1,0x03)

 TLS_GOSTR341112_256_WITH_MAGMA_MGM_L (0xC1,0x04)

 TLS_GOSTR341112_256_WITH_KUZNYECHIK_MGM_S (0xC1,0x05)

 TLS_GOSTR341112_256_WITH_MAGMA_MGM_S (0xC1,0x06).

**Application Security Verification Standard 4.0, OWASP**

https://habr.com/ru/company/owasp/blog/519050/

___
