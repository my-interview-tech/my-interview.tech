---
title: Отношение "один к одному"
draft: false
tags:
  - SQL
  - БД
info:
---
Каждый элемент из первой таблицы связан ровно с одним элементом из второй таблицы.

**Важные особенности реализации**

**Проблема**: В SQL нет встроенного механизма для истинных отношений "один к одному". Обычно используется внешний ключ с ограничением UNIQUE.

**Способы реализации**:

1. **Внешний ключ с UNIQUE** (наиболее распространенный)
2. **Объединение таблиц** (если данные логически связаны)
3. **Использование триггеров** для дополнительной валидации

Пример: Пользователи и Паспортные данные

```sql
-- Создание таблицы пользователей
CREATE TABLE users (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- Создание таблицы паспортных данных
CREATE TABLE passport_data (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT UNIQUE,  -- Ключевое ограничение UNIQUE
    passport_number VARCHAR(20) UNIQUE NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    birth_date DATE NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Вставка данных
INSERT INTO users (username, email) VALUES
('john_doe', 'john@example.com'),
('jane_smith', 'jane@example.com');

INSERT INTO passport_data (user_id, passport_number, first_name, last_name, birth_date) VALUES
(1, '1234567890', 'Джон', 'Доу', '1990-05-15'),
(2, '0987654321', 'Джейн', 'Смит', '1985-12-03');
```

**Альтернативный подход: Объединение таблиц**

Если данные логически связаны и всегда используются вместе:

```sql
-- Альтернативный подход - объединение в одну таблицу
CREATE TABLE users_with_passport (
    id INT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) UNIQUE NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,
    passport_number VARCHAR(20) UNIQUE,
    first_name VARCHAR(50),
    last_name VARCHAR(50),
    birth_date DATE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);
```

**Ограничения и проблемы**

```sql
-- Проблема: можно создать запись в passport_data без соответствующего user_id
-- Решение: использовать NOT NULL
CREATE TABLE passport_data_improved (
    id INT PRIMARY KEY AUTO_INCREMENT,
    user_id INT NOT NULL UNIQUE,  -- NOT NULL предотвращает "висящие" записи
    passport_number VARCHAR(20) UNIQUE NOT NULL,
    first_name VARCHAR(50) NOT NULL,
    last_name VARCHAR(50) NOT NULL,
    birth_date DATE NOT NULL,
    FOREIGN KEY (user_id) REFERENCES users(id)
);

-- Дополнительная защита через триггер (PostgreSQL)
CREATE OR REPLACE FUNCTION check_one_to_one()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        -- Проверяем, что пользователь существует
        IF NOT EXISTS (SELECT 1 FROM users WHERE id = NEW.user_id) THEN
            RAISE EXCEPTION 'User with id % does not exist', NEW.user_id;
        END IF;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER passport_data_one_to_one
    BEFORE INSERT OR UPDATE ON passport_data_improved
    FOR EACH ROW EXECUTE FUNCTION check_one_to_one();
```

___
