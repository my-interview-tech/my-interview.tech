---
title: Что такое http.Agent и как он управляет соединениями
draft: false
tags:
  - "#NodeJS"
  - "#HTTP"
  - "#соединения"
  - "#оптимизация"
  - "#сеть"
  - "#производительность"
info:
  - https://nodejs.org/api/http.html#class-httpagent
  - https://nodejs.org/api/http.html#new-agentoptions
  - https://habr.com/ru/articles/693284/
---

# Что такое http.Agent и как он управляет соединениями

`http.Agent` в Node.js — это объект, который управляет пулом **TCP-соединений** для HTTP-запросов. Он используется для повторного использования соединений, что помогает оптимизировать производительность и уменьшить накладные расходы на создание новых соединений для каждого запроса.

## Принцип работы http.Agent

### 1. Пул соединений

`http.Agent` поддерживает пул TCP-соединений для каждого уникального хоста:порт. Вместо создания нового соединения при каждом запросе, агент пытается использовать существующее из пула, что значительно ускоряет выполнение запросов.

### 2. Автоматическое управление соединениями

`http.Agent` управляет:

- Открытием новых соединений
- Поддержанием активных соединений
- Закрытием неиспользуемых соединений
- Очередью запросов, ожидающих соединения

### 3. Параллельные запросы

При большом количестве запросов к одному и тому же хосту, `http.Agent` эффективно распределяет их между доступными соединениями или создает новые в рамках заданных ограничений.

## Ключевые параметры http.Agent

```javascript
const http = require("http")

const agent = new http.Agent({
  keepAlive: true, // Оставлять соединения открытыми
  keepAliveMsecs: 1000, // Интервал проверки соединений (мс)
  maxSockets: 10, // Максимум соединений к одному хосту
  maxFreeSockets: 5, // Максимум свободных соединений в пуле
  timeout: 60000, // Таймаут сокета (мс)
})
```

| Параметр         | Описание                                     | Значение по умолчанию |
| ---------------- | -------------------------------------------- | --------------------- |
| `keepAlive`      | Оставлять соединения открытыми после запроса | `false`               |
| `keepAliveMsecs` | Интервал проверки keepAlive соединений       | `1000` мс             |
| `maxSockets`     | Максимум соединений на хост:порт             | `Infinity`            |
| `maxFreeSockets` | Максимум свободных соединений в пуле         | `256`                 |
| `timeout`        | Таймаут для сокетов                          | —                     |
| `scheduling`     | Стратегия планирования ('fifo' или 'lifo')   | `'lifo'`              |

## Пример использования http.Agent

### Базовый пример

```javascript
const http = require("http")

// Создание кастомного агента
const agent = new http.Agent({
  keepAlive: true, // Оставляем соединения открытыми
  maxSockets: 10, // Максимум 10 соединений к одному хосту
  maxFreeSockets: 5, // Максимум 5 неактивных соединений в пуле
})

const options = {
  hostname: "example.com",
  port: 80,
  path: "/",
  agent: agent, // Используем кастомный агент
}

http
  .get(options, (res) => {
    let data = ""

    res.on("data", (chunk) => {
      data += chunk
    })

    res.on("end", () => {
      console.log(data)
    })
  })
  .on("error", (err) => {
    console.log("Error:", err.message)
  })
```

### Пример с множественными запросами

```javascript
const http = require("http")

const agent = new http.Agent({
  keepAlive: true,
  maxSockets: 5,
})

// Выполнение 10 последовательных запросов
for (let i = 0; i < 10; i++) {
  const options = {
    hostname: "example.com",
    port: 80,
    path: `/resource${i}`,
    agent: agent,
  }

  http
    .get(options, (res) => {
      console.log(`Запрос ${i}, статус: ${res.statusCode}`)

      // Потребление тела ответа для освобождения соединения
      res.resume()
    })
    .on("error", (err) => {
      console.error(`Запрос ${i} завершился ошибкой: ${err.message}`)
    })
}
```

## Преимущества использования http.Agent

### 1. Повышение производительности

Повторное использование соединений устраняет затраты на:

- TCP-рукопожатие (handshake)
- SSL/TLS-согласование (для HTTPS)
- Установку TCP slow-start

### 2. Снижение нагрузки

Контролируя количество одновременных соединений, `http.Agent` предотвращает перегрузку сервера и локальных ресурсов.

### 3. Оптимизация для микросервисной архитектуры

В микросервисной архитектуре, где сервисы постоянно общаются между собой, правильная настройка `http.Agent` может значительно снизить задержки и увеличить пропускную способность.

## Когда использовать кастомный http.Agent

### 1. Высоконагруженные приложения

Когда ваше приложение выполняет множество запросов к одним и тем же хостам.

### 2. Микросервисная архитектура

Для оптимизации внутренних коммуникаций между сервисами.

### 3. Сценарии с особыми требованиями

- При необходимости точного контроля над количеством соединений
- При балансировке запросов между несколькими серверами
- При работе с API, имеющими ограничения по частоте запросов

## Отключение использования агента

Если нужно для каждого запроса создавать новое соединение:

```javascript
const http = require("http")

const options = {
  hostname: "example.com",
  port: 80,
  path: "/",
  agent: false, // Отключаем использование агента
}

http.get(options, (res) => {
  // Обработка ответа
})
```

## Глобальный агент по умолчанию

Node.js использует глобальный экземпляр `http.Agent` для всех HTTP-запросов, если не указан конкретный агент:

```javascript
// Доступ к глобальному агенту
const globalAgent = http.globalAgent

// Изменение параметров глобального агента
http.globalAgent.maxSockets = 20
```

---

[[003 JSCore|Назад]]
