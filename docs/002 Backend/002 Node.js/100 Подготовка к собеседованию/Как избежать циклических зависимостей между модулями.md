---
title: Как избежать циклических зависимостей между модулями
draft: false
tags:
  - "#NodeJS"
  - "#модули"
  - "#архитектура"
  - "#CommonJS"
  - "#ES_Modules"
info:
  - https://nodejs.org/api/modules.html#modules_cycles
  - https://nodejs.org/api/esm.html#esm_import_statements
---

Циклические зависимости – это ситуация, когда модуль A импортирует модуль B, а модуль B импортирует модуль A (напрямую или через цепочку импортов). Хотя Node.js может работать с циклическими зависимостями, они могут вызывать неожиданное поведение и усложнять понимание и отладку кода.

## Проблемы с циклическими зависимостями

### 1. Неполные объекты при импорте

В CommonJS (традиционная система модулей Node.js) циклические зависимости могут приводить к получению неполного объекта, если один модуль не завершил свое выполнение:

```javascript
// moduleA.js
const moduleB = require("./moduleB")
console.log("moduleB от A:", moduleB) // может быть {} или неполным объектом
module.exports = { name: "Module A" }

// moduleB.js
const moduleA = require("./moduleA")
console.log("moduleA от B:", moduleA) // часто будет {}
module.exports = { name: "Module B" }
```

### 2. Трудности с отладкой

Циклические зависимости усложняют отладку, поскольку порядок загрузки модулей не всегда очевиден, а ошибки могут проявляться случайным образом.

### 3. Затруднение рефакторинга

Модули с циклическими зависимостями сложнее рефакторить или тестировать по отдельности из-за их тесной связанности.

## Стратегии устранения циклических зависимостей

### 1. Реорганизация модулей

Наиболее эффективный подход – реорганизация кода и разделение функциональности:

1. **Анализ зависимостей**: Определите, какие части функциональности действительно нужны в каждом модуле
2. **Выделение общего кода**: Вынесите общую функциональность в отдельный модуль, который будет импортироваться обоими модулями

**Пример улучшения:**

```javascript
// Было:
// moduleA импортирует moduleB, moduleB импортирует moduleA

// Стало:
// commonUtils.js - общий модуль
module.exports = {
  sharedFunction: function () {
    /* ... */
  },
  sharedData: {
    /* ... */
  },
}

// moduleA.js
const common = require("./commonUtils")
module.exports = {
  featureA: function () {
    // использует common.sharedFunction()
  },
}

// moduleB.js
const common = require("./commonUtils")
module.exports = {
  featureB: function () {
    // использует common.sharedFunction()
  },
}
```

### 2. Использование отложенной загрузки (Lazy Loading)

Загружайте зависимые модули внутри функций, а не на верхнем уровне модуля:

```javascript
// moduleA.js
module.exports = {
  doSomething: function () {
    // Импортируем moduleB только когда необходимо
    const moduleB = require("./moduleB")
    return moduleB.process()
  },
}

// moduleB.js
module.exports = {
  process: function () {
    // Если необходимо, импортируем moduleA внутри функции
    const moduleA = require("./moduleA")
    return "Результат обработки"
  },
}
```

### 3. Использование фабрик или внедрения зависимостей

Передавайте зависимости явно, а не импортируйте их напрямую:

```javascript
// moduleA.js
module.exports = function createModuleA(dependencies = {}) {
  return {
    run: function () {
      if (dependencies.moduleB) {
        return dependencies.moduleB.execute()
      }
      return "Default result"
    },
  }
}

// moduleB.js
module.exports = function createModuleB(dependencies = {}) {
  return {
    execute: function () {
      if (dependencies.moduleA) {
        return "Используем moduleA: " + dependencies.moduleA.run()
      }
      return "Execute result"
    },
  }
}

// app.js - сборка зависимостей
const moduleAFactory = require("./moduleA")
const moduleBFactory = require("./moduleB")

const moduleA = moduleAFactory()
const moduleB = moduleBFactory({ moduleA })
// Обновляем moduleA зависимостью на moduleB
Object.assign(moduleA, moduleAFactory({ moduleB }))
```

### 4. Использование событийной модели

События (Event Emitter) помогают разорвать прямые зависимости:

```javascript
// eventBus.js
const EventEmitter = require("events")
module.exports = new EventEmitter()

// moduleA.js
const eventBus = require("./eventBus")
eventBus.on("eventFromB", (data) => {
  console.log("Module A получил событие:", data)
})
module.exports = {
  triggerEvent: () => eventBus.emit("eventFromA", { source: "Module A" }),
}

// moduleB.js
const eventBus = require("./eventBus")
eventBus.on("eventFromA", (data) => {
  console.log("Module B получил событие:", data)
})
module.exports = {
  triggerEvent: () => eventBus.emit("eventFromB", { source: "Module B" }),
}
```

### 5. Использование ES Modules с динамическим импортом

В современном JavaScript можно использовать динамические импорты:

```javascript
// moduleA.js
export async function needsModuleB() {
  // Динамический импорт возвращает Promise
  const moduleB = await import('./moduleB.js');
  return moduleB.default.process();
}

export default { name: 'Module A' };

// moduleB.js
export async function needsModuleA() {
  const moduleA = await import('./moduleA.js');
  return moduleA.default.name;
}

export default { name: 'Module B', process: () => 'Processed' };
```

## Инструменты для выявления циклических зависимостей

1. **madge**: Анализирует зависимости и находит циклы:

   ```bash
   npm install -g madge
   madge --circular --extensions js ./path/to/your/code
   ```

2. **ESLint с плагином import-cycles**:

   ```bash
   npm install --save-dev eslint eslint-plugin-import-cycles
   ```

3. **dependency-cruiser**:
   ```bash
   npm install -g dependency-cruiser
   depcruise --output-type dot --max-depth 4 ./src | dot -T svg > dependencies.svg
   ```

## Заключение

Хотя Node.js позволяет работать с циклическими зависимостями, лучше их избегать для создания более чистой и поддерживаемой архитектуры. Основные подходы:

1. **Реорганизуйте модули** с выделением общей функциональности
2. **Используйте отложенную загрузку** зависимостей
3. **Применяйте паттерны внедрения зависимостей**
4. **Используйте шину событий** для коммуникации между модулями
5. **Регулярно анализируйте зависимости** с помощью инструментов

---

[[002 Node.js|Назад]]
