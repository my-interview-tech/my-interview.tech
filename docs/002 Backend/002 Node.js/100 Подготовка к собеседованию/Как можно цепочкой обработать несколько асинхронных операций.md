---
title: Как можно цепочкой обработать несколько асинхронных операций
draft: false
tags:
  - "#NodeJS"
  - "#JavaScript"
  - "#асинхронность"
  - "#промисы"
  - "#async-await"
  - "#callback"
info:
  - "[Документация MDN по Promise](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise)"
  - "[Документация Node.js по async/await](https://nodejs.org/api/async_hooks.html)"
  - "[Руководство по асинхронному JavaScript](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous)"
---

В Node.js существует несколько подходов для последовательного выполнения асинхронных операций. Каждый из них имеет свои преимущества и особенности применения.

## 1. Цепочка обработки с использованием callbacks

Самый базовый подход – использование вложенных callback-функций:

```javascript
const fs = require("fs")

fs.readFile("file1.txt", "utf8", (err, data1) => {
  if (err) {
    return console.error("Ошибка при чтении первого файла:", err)
  }

  fs.readFile("file2.txt", "utf8", (err, data2) => {
    if (err) {
      return console.error("Ошибка при чтении второго файла:", err)
    }

    const result = data1 + data2

    fs.writeFile("combined.txt", result, (err) => {
      if (err) {
        return console.error("Ошибка при записи файла:", err)
      }
      console.log("Файлы успешно объединены и сохранены")
    })
  })
})
```

Основной недостаток – "callback hell" (ад колбэков), когда код становится трудночитаемым из-за большой вложенности.

## 2. Использование Promise-цепочек

Промисы позволяют создавать более плоские цепочки асинхронных операций:

```javascript
const fs = require("fs").promises

fs.readFile("file1.txt", "utf8")
  .then((data1) => {
    return fs.readFile("file2.txt", "utf8").then((data2) => {
      return { data1, data2 }
    })
  })
  .then((result) => {
    const combinedData = result.data1 + result.data2
    return fs.writeFile("combined.txt", combinedData)
  })
  .then(() => {
    console.log("Файлы успешно объединены и сохранены")
  })
  .catch((err) => {
    console.error("Произошла ошибка:", err)
  })
```

Более чистый подход с использованием цепочки Promise.then():

```javascript
const fs = require("fs").promises
let firstFileData

fs.readFile("file1.txt", "utf8")
  .then((data1) => {
    firstFileData = data1
    return fs.readFile("file2.txt", "utf8")
  })
  .then((data2) => {
    const combinedData = firstFileData + data2
    return fs.writeFile("combined.txt", combinedData)
  })
  .then(() => {
    console.log("Файлы успешно объединены и сохранены")
  })
  .catch((err) => {
    console.error("Произошла ошибка:", err)
  })
```

## 3. Async/Await – современный подход

Самый современный и читаемый подход – использование async/await:

```javascript
const fs = require("fs").promises

async function combineFiles() {
  try {
    // Последовательное чтение файлов
    const data1 = await fs.readFile("file1.txt", "utf8")
    const data2 = await fs.readFile("file2.txt", "utf8")

    // Объединение и запись результата
    const combinedData = data1 + data2
    await fs.writeFile("combined.txt", combinedData)

    console.log("Файлы успешно объединены и сохранены")
  } catch (err) {
    console.error("Произошла ошибка:", err)
  }
}

combineFiles()
```

## 4. Параллельное выполнение с Promise.all()

Если операции независимы друг от друга, их можно выполнить параллельно:

```javascript
const fs = require("fs").promises

async function combineFilesParallel() {
  try {
    // Параллельное чтение файлов
    const [data1, data2] = await Promise.all([
      fs.readFile("file1.txt", "utf8"),
      fs.readFile("file2.txt", "utf8"),
    ])

    // Объединение и запись результата
    const combinedData = data1 + data2
    await fs.writeFile("combined.txt", combinedData)

    console.log("Файлы успешно объединены и сохранены")
  } catch (err) {
    console.error("Произошла ошибка:", err)
  }
}

combineFilesParallel()
```

## 5. Использование сторонних библиотек

Для сложных последовательностей можно использовать специализированные библиотеки:

```javascript
const async = require("async")
const fs = require("fs")

async.waterfall(
  [
    (callback) => {
      fs.readFile("file1.txt", "utf8", callback)
    },
    (data1, callback) => {
      fs.readFile("file2.txt", "utf8", (err, data2) => {
        if (err) return callback(err)
        callback(null, data1, data2)
      })
    },
    (data1, data2, callback) => {
      const combinedData = data1 + data2
      fs.writeFile("combined.txt", combinedData, callback)
    },
  ],
  (err) => {
    if (err) {
      return console.error("Произошла ошибка:", err)
    }
    console.log("Файлы успешно объединены и сохранены")
  },
)
```

## Выбор подхода

| Подход      | Когда использовать                                                                     |
| ----------- | -------------------------------------------------------------------------------------- |
| Callbacks   | В простых случаях или при работе с устаревшим API                                      |
| Promises    | Для большинства приложений Node.js, особенно при необходимости гибкой обработки ошибок |
| Async/Await | Для максимальной читабельности кода и простоты поддержки                               |
| Promise.all | Когда операции могут выполняться параллельно без зависимостей                          |

Современная рекомендация – использовать async/await везде, где это возможно, для наиболее чистого и понятного кода.

---

[[002 Node.js|Назад]]
