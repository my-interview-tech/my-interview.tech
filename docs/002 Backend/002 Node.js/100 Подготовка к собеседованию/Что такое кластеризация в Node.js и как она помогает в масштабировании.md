---
title: Что такое кластеризация в Node.js и как она помогает в масштабировании
draft: false
tags:
  - "#NodeJS"
  - "#Кластеризация"
  - "#Масштабирование"
  - "#Производительность"
  - "#Многоядерность"
info:
  - "[Документация Node.js - Cluster](https://nodejs.org/api/cluster.html)"
  - "[Node.js Scaling с PM2](https://pm2.io/docs/runtime/guide/load-balancing/)"
---

![[Pasted image node-cluster.png|600]]

## Кластеризация в Node.js

**Кластеризация** в Node.js — это процесс создания нескольких процессов (воркеров) для распределения нагрузки на многоядерных системах. По умолчанию Node.js работает в одном потоке, что не позволяет приложению использовать все доступные ядра CPU. Модуль `cluster` решает эту проблему.

## Базовый принцип работы

Модуль `cluster` позволяет создать главный процесс (master), который запускает дочерние процессы (workers). Все входящие соединения распределяются между рабочими процессами с помощью алгоритма Round-Robin.

```javascript
const cluster = require("cluster")
const http = require("http")
const numCPUs = require("os").cpus().length

if (cluster.isMaster) {
  console.log(`Главный процесс ${process.pid} запущен`)

  // Создаем рабочий процесс для каждого ядра
  for (let i = 0; i < numCPUs; i++) {
    cluster.fork()
  }

  cluster.on("exit", (worker, code, signal) => {
    console.log(`Рабочий процесс ${worker.process.pid} завершился`)
    // При необходимости можно запустить новый воркер
    cluster.fork()
  })
} else {
  // Рабочие процессы могут совместно использовать TCP-соединение
  http
    .createServer((req, res) => {
      res.writeHead(200)
      res.end("Привет от процесса " + process.pid + "\n")
    })
    .listen(8000)

  console.log(`Рабочий процесс ${process.pid} запущен`)
}
```

## Преимущества кластеризации

1. **Повышение производительности**: использование всех доступных ядер процессора.
2. **Отказоустойчивость**: если один из рабочих процессов выходит из строя, остальные продолжают работать.
3. **Равномерное распределение нагрузки**: входящие запросы распределяются между рабочими процессами.
4. **Нулевое время простоя при обновлении**: возможность перезапуска процессов без прерывания обслуживания.

## Методы балансировки нагрузки

Node.js предлагает два метода балансировки нагрузки:

1. **Round-Robin**: (по умолчанию, кроме Windows) запросы распределяются по очереди между рабочими процессами.
2. **Случайное распределение**: (используется в Windows) соединения назначаются случайному рабочему процессу.

```javascript
// Настройка метода балансировки
if (cluster.isMaster) {
  cluster.schedulingPolicy = cluster.SCHED_RR // Round-Robin (по умолчанию)
  // или
  cluster.schedulingPolicy = cluster.SCHED_NONE // Случайное распределение
}
```

## Коммуникация между процессами

Рабочие процессы могут отправлять сообщения главному процессу и наоборот:

```javascript
if (cluster.isMaster) {
  const worker = cluster.fork()

  // Отправка сообщения рабочему процессу
  worker.send({ cmd: "config", data: { port: 8000 } })

  // Получение сообщения от рабочего процесса
  worker.on("message", (msg) => {
    console.log(`Получено сообщение от рабочего процесса ${worker.id}:`, msg)
  })
} else {
  // Получение сообщения от главного процесса
  process.on("message", (msg) => {
    console.log("Рабочий процесс получил сообщение:", msg)

    // Отправка сообщения главному процессу
    process.send({ status: "ready", pid: process.pid })
  })
}
```

## Использование PM2 для кластеризации

PM2 — это менеджер процессов для Node.js с встроенной поддержкой кластеризации:

```javascript
// ecosystem.config.js
module.exports = {
  apps: [
    {
      name: "app",
      script: "app.js",
      instances: "max", // использовать все доступные CPU
      exec_mode: "cluster",
      watch: true,
      env: {
        NODE_ENV: "development",
      },
      env_production: {
        NODE_ENV: "production",
      },
    },
  ],
}
```

Запуск приложения с PM2:

```bash
pm2 start ecosystem.config.js
```

## Обработка состояния и общие данные

Поскольку кластеризация создает отдельные процессы, они не разделяют общую память. Для обмена данными между процессами можно использовать:

1. **Внешние хранилища**: Redis, MongoDB, и т.д.
2. **Обмен сообщениями**: через механизм сообщений кластера
3. **Sticky sessions**: направление запросов одного клиента на один и тот же рабочий процесс

```javascript
// Пример использования Redis для общего состояния
const cluster = require("cluster")
const Redis = require("ioredis")

if (cluster.isMaster) {
  for (let i = 0; i < 4; i++) {
    cluster.fork()
  }
} else {
  const redis = new Redis()
  const app = require("express")()

  app.get("/counter", async (req, res) => {
    const count = await redis.incr("counter")
    res.send(`Счетчик: ${count} (процесс ${process.pid})`)
  })

  app.listen(3000)
}
```

## Ограничения и особенности

1. **Увеличение потребления памяти**: каждый процесс имеет свою собственную память
2. **Нет общего состояния**: необходимо использовать внешние хранилища для обмена данными
3. **Сложность отладки**: отладка кластеризованного приложения может быть сложнее
4. **Задержка запуска**: старт нескольких процессов занимает больше времени

---

[[002 Node.js|Назад]]
