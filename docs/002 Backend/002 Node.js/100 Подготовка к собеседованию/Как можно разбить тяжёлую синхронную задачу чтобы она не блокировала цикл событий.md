---
title: Как можно разбить тяжёлую синхронную задачу чтобы она не блокировала цикл событий?
draft: true
tags:
  - NodeJS
  - EventLoop
  - setImmediate
  - setTimeout
  - nextTick
info:
---
Чтобы тяжёлая синхронная задача не блокировала Event Loop в Node.js, её можно **разбить на части** и выполнять **асинхронно** с использованием:

**1. `setImmediate()` или `setTimeout(fn, 0)`**

Позволяет передавать управление Event Loop между итерациями.

```javascript
function heavyTask(iterations) {   
	let i = 0;   
	
	function next() {     

		const start = Date.now();     

		while (i < iterations && Date.now() - start < 10) {       
			i++; // Выполняем часть работы     
		}     

	if (i < iterations) setImmediate(next); // Планируем следующую часть   
	}   
	
	next(); 
} 

heavyTask(1e6);`
```

**2. `process.nextTick()` (не рекомендуется для долгих задач)**

Можно использовать для **разбиения**, но не даёт Event Loop обработать другие задачи. Лучше `setImmediate()`.

```javascript
function heavyTask() {   
	process.nextTick(heavyTask); // Опасно: может заблокировать Event Loop 
}
```

**3. Worker Threads (лучший вариант для CPU-нагрузки)**

Для действительно тяжёлых задач лучше вынести вычисления в **поток**.

```javascript
const { Worker } = require("worker_threads"); 

const worker = new Worker("./worker.js"); // Код будет выполняться в другом потоке`
```

**Итог**
- **Мелкие задачи** → `setImmediate()` / `setTimeout(fn, 0)`.
- **Тяжёлые CPU-вычисления** → `Worker Threads`.
- **Не использовать `process.nextTick()` для тяжёлых задач** (может заблокировать Event Loop).