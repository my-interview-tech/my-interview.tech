---
title: Как можно разбить тяжёлую синхронную задачу чтобы она не блокировала цикл событий
draft: false
tags:
  - "#NodeJS"
  - "#EventLoop"
  - "#производительность"
  - "#setImmediate"
  - "#setTimeout"
  - "#workers"
  - "#многопоточность"
info:
  - "[Документация Node.js по Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)"
  - "[Документация по Worker Threads](https://nodejs.org/api/worker_threads.html)"
  - "[Статья о неблокирующем коде в Node.js](https://nodejs.org/en/docs/guides/dont-block-the-event-loop/)"
---

Node.js использует однопоточную модель выполнения с асинхронным вводом-выводом, что делает его эффективным для задач с интенсивной работой с I/O. Однако тяжелые синхронные CPU-интенсивные операции могут блокировать цикл событий (Event Loop), препятствуя обработке других запросов или событий.

Существует несколько подходов к разбиению тяжелых синхронных задач для предотвращения блокировки цикла событий.

## 1. Разбиение с помощью setTimeout и setImmediate

Самый простой подход — разбить задачу на небольшие части и запланировать их выполнение с помощью `setTimeout` или `setImmediate`, позволяя циклу событий обрабатывать другие операции между итерациями.

### Пример с использованием setImmediate

```javascript
function processArray(array, callback) {
  const chunk = 1000 // размер обрабатываемой порции
  let index = 0

  function processChunk() {
    const start = Date.now()

    // Обрабатываем данные до тех пор, пока не закончатся или не превысим лимит времени
    while (index < array.length && Date.now() - start < 10) {
      // Выполняем операцию с текущим элементом
      const item = array[index]
      // ... обработка элемента ...
      index++
    }

    // Проверяем, завершена ли обработка
    if (index < array.length) {
      // Если не завершена, планируем следующую порцию
      setImmediate(processChunk)
    } else {
      // Завершаем обработку
      callback(null, "Обработка завершена")
    }
  }

  // Запускаем обработку первой порции
  processChunk()
}

// Пример использования
const largeArray = new Array(1000000).fill(1)
processArray(largeArray, (err, result) => {
  if (err) {
    console.error("Ошибка:", err)
  } else {
    console.log(result)
  }
})

// Это не будет заблокировано
console.log("Это сообщение выведется сразу")
```

### Пример с использованием setTimeout

```javascript
function heavyTask(iterations, callback) {
  let i = 0

  // Функция обработки одной порции
  function processNextChunk() {
    const endTime = Date.now() + 15 // Максимум 15 мс на обработку

    // Обрабатываем порцию данных
    while (i < iterations && Date.now() < endTime) {
      // ... тяжелые вычисления ...
      i++
    }

    // Проверяем, завершили ли обработку
    if (i < iterations) {
      // Если нет, планируем следующую порцию через 0 мс
      setTimeout(processNextChunk, 0)
    } else {
      // Если да, вызываем callback
      callback(null, i)
    }
  }

  // Запускаем обработку
  processNextChunk()
}

// Использование
heavyTask(10000000, (err, result) => {
  console.log(`Завершена обработка ${result} итераций`)
})

// Это выполнится сразу, не дожидаясь завершения heavyTask
console.log("Выполнение продолжается...")
```

### Отличия между setTimeout(fn, 0) и setImmediate()

- `setTimeout(fn, 0)` добавляет задачу в очередь таймеров и выполняет не раньше, чем в следующей итерации цикла событий
- `setImmediate()` добавляет задачу в специальную очередь, которая выполняется сразу после фазы операций I/O
- В большинстве случаев `setImmediate()` предпочтительнее для неблокирующей обработки, так как гарантирует выполнение после всех I/O колбэков

## 2. Использование process.nextTick()

`process.nextTick()` можно использовать для планирования задач, но с осторожностью, так как вызовы `nextTick` выполняются до возврата в цикл событий:

```javascript
function countWithNextTick(n, callback) {
  let count = 0

  function increment() {
    count++

    if (count < n) {
      // ВНИМАНИЕ: может блокировать Event Loop при большом количестве вызовов
      process.nextTick(increment)
    } else {
      callback(null, count)
    }
  }

  increment()
}
```

> **Важно**: Чрезмерное использование `process.nextTick()` может фактически блокировать цикл событий, так как очередь nextTick имеет приоритет над другими операциями и выполняется до того, как Event Loop перейдет к следующей фазе.

## 3. Использование Worker Threads

Для действительно тяжелых вычислений, лучше использовать модуль `worker_threads`, который позволяет выполнять JavaScript в параллельных потоках:

```javascript
const { Worker, isMainThread, parentPort, workerData } = require("worker_threads")

if (isMainThread) {
  // Код в основном потоке
  function runHeavyTaskInWorker(data) {
    return new Promise((resolve, reject) => {
      const worker = new Worker(__filename, {
        workerData: data,
      })

      worker.on("message", resolve)
      worker.on("error", reject)
      worker.on("exit", (code) => {
        if (code !== 0) {
          reject(new Error(`Worker остановился с кодом выхода ${code}`))
        }
      })
    })
  }

  // Использование worker для выполнения тяжелой задачи
  runHeavyTaskInWorker({ iterations: 100000000 })
    .then((result) => console.log("Результат:", result))
    .catch((err) => console.error("Ошибка:", err))

  // Это выполнится без блокировки
  console.log("Основной поток не блокируется")
} else {
  // Код, выполняемый в worker-потоке
  const { iterations } = workerData
  let result = 0

  // Здесь можно выполнять тяжелые вычисления
  for (let i = 0; i < iterations; i++) {
    result += i
  }

  // Отправляем результат обратно в основной поток
  parentPort.postMessage(result)
}
```

Worker Threads имеют следующие преимущества:

- Не блокируют основной поток и цикл событий
- Могут использовать все доступные ядра процессора
- Подходят для CPU-интенсивных операций

## 4. Использование сторонних библиотек

Для сложных вычислений можно использовать специализированные библиотеки:

### Пример с библиотекой async

```javascript
const async = require("async")

function processLargeData(data, callback) {
  // Разбиваем данные на части
  const chunks = chunkArray(data, 1000)

  async.eachSeries(
    chunks,
    (chunk, chunkCallback) => {
      // Обработка в следующем тике цикла событий
      setImmediate(() => {
        try {
          // Обработка порции данных
          processChunk(chunk)
          chunkCallback()
        } catch (err) {
          chunkCallback(err)
        }
      })
    },
    callback,
  )
}

function chunkArray(array, size) {
  const result = []
  for (let i = 0; i < array.length; i += size) {
    result.push(array.slice(i, i + size))
  }
  return result
}

function processChunk(chunk) {
  // Обработка порции данных
  chunk.forEach((item) => {
    // ... тяжелые вычисления ...
  })
}
```

## 5. Последовательность обработки в цикле событий Node.js

Понимание последовательности выполнения в цикле событий поможет выбрать правильный подход:

1. **Таймеры**: Выполнение колбэков setTimeout/setInterval
2. **Ожидающие колбэки**: Выполнение отложенных I/O колбэков
3. **Фаза idle/prepare**: Только для внутреннего использования
4. **Фаза poll**: Получение новых I/O событий
5. **Фаза check**: Выполнение колбэков setImmediate
6. **Фаза close callbacks**: Выполнение закрывающих колбэков

После каждой фазы выполняются все колбэки, запланированные через `process.nextTick()`.

## Рекомендации по выбору подхода

| Сложность задачи                                    | Рекомендуемый подход                               |
| --------------------------------------------------- | -------------------------------------------------- |
| Легкая (небольшие массивы, простые вычисления)      | setTimeout/setImmediate                            |
| Средняя (обработка данных средних объемов)          | Разбиение на порции с контролем времени выполнения |
| Тяжелая (сложные вычисления, большие объемы данных) | Worker Threads                                     |

## Заключение

При выборе способа разбиения тяжелой задачи в Node.js следует учитывать:

1. **Природу задачи**: IO-bound или CPU-bound
2. **Объем данных**: от этого зависит размер порций обработки
3. **Требования к отзывчивости**: насколько критично, чтобы приложение оставалось отзывчивым
4. **Доступные ресурсы**: память, CPU, количество ядер

Правильное разбиение задач обеспечивает эффективное использование ресурсов и предотвращает блокировку цикла событий, что особенно важно для высоконагруженных Node.js приложений.

---

[[002 Node.js|Назад]]
