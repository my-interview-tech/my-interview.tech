---
title: В чем разница между microtasks и macrotasks
draft: false
tags:
  - "#NodeJS"
  - "#JavaScript"
  - "#EventLoop"
  - "#асинхронность"
  - "#Promise"
  - "#event-loop"
info:
  - "[Документация Node.js: Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)"
  - "[Спецификация HTML: Event Loop](https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model)"
  - "[JavaScript.info: Микрозадачи и макрозадачи](https://javascript.info/event-loop)"
---

# Разница между microtasks и macrotasks

В JavaScript и Node.js асинхронные операции обрабатываются через цикл событий (Event Loop), который разделяет задачи на две основные категории: **микрозадачи (microtasks)** и **макрозадачи (macrotasks)**. Эти категории имеют разные приоритеты и обрабатываются по-разному, что существенно влияет на порядок выполнения асинхронного кода.

## Макрозадачи (Macrotasks)

**Макрозадачи** (также известные как задачи или tasks) представляют собой обычные асинхронные операции, которые планируются и выполняются цикл за циклом.

### Основные источники макрозадач:

- `setTimeout()` и `setInterval()`
- `setImmediate()` (специфично для Node.js)
- Операции I/O (запросы к серверу, чтение файлов и т.д.)
- UI-рендеринг и обработка событий DOM (в браузерах)
- Обработчики событий (клики, нажатия клавиш и т.д.)
- `requestAnimationFrame()` (в браузерах)

### Пример макрозадачи:

```javascript
console.log("Начало скрипта")

setTimeout(() => {
  console.log("Макрозадача (setTimeout)")
}, 0)

console.log("Конец скрипта")

// Вывод:
// Начало скрипта
// Конец скрипта
// Макрозадача (setTimeout)
```

## Микрозадачи (Microtasks)

**Микрозадачи** представляют собой асинхронные операции с более высоким приоритетом, которые выполняются сразу после текущей задачи, до начала следующей макрозадачи.

### Основные источники микрозадач:

- Promise (.then/.catch/.finally)
- queueMicrotask()
- process.nextTick() (специфично для Node.js, имеет еще более высокий приоритет)
- MutationObserver (в браузерах)

### Пример микрозадачи:

```javascript
console.log("Начало скрипта")

Promise.resolve().then(() => {
  console.log("Микрозадача (Promise)")
})

console.log("Конец скрипта")

// Вывод:
// Начало скрипта
// Конец скрипта
// Микрозадача (Promise)
```

## Порядок выполнения задач

При работе цикла событий последовательность выполнения задач следующая:

1. Выполнить текущий синхронный код до конца
2. Проверить очередь микрозадач:
   - Если есть микрозадачи, выполнить их **все**, включая новые микрозадачи, которые могут добавляться в процессе выполнения
3. Выполнить **одну** макрозадачу из очереди
4. Снова проверить очередь микрозадач и выполнить их все
5. Выполнить следующую макрозадачу и так далее

## Наглядный пример разницы между макро- и микрозадачами

```javascript
console.log("1. Синхронный код")

setTimeout(() => {
  console.log("2. Макрозадача 1 (setTimeout)")

  Promise.resolve().then(() => console.log("3. Микрозадача в макрозадаче 1"))

  console.log("4. Синхронный код в макрозадаче 1")
}, 0)

Promise.resolve()
  .then(() => {
    console.log("5. Микрозадача 1")

    setTimeout(() => {
      console.log("6. Макрозадача 2 из микрозадачи 1")
    }, 0)
  })
  .then(() => {
    console.log("7. Микрозадача 2")
  })

console.log("8. Синхронный код (конец)")

// Порядок вывода:
// 1. Синхронный код
// 8. Синхронный код (конец)
// 5. Микрозадача 1
// 7. Микрозадача 2
// 2. Макрозадача 1 (setTimeout)
// 4. Синхронный код в макрозадаче 1
// 3. Микрозадача в макрозадаче 1
// 6. Макрозадача 2 из микрозадачи 1
```

## Особенности в Node.js

В Node.js есть некоторые отличия в обработке задач по сравнению с браузерами:

1. **process.nextTick()**: Функция `process.nextTick()` в Node.js создает задачи, которые выполняются перед всеми другими микрозадачами и макрозадачами. Они выполняются непосредственно после завершения текущего кода, даже перед микрозадачами Promise.

2. **setImmediate()**: Запланированные через `setImmediate()` функции выполняются в фазе "check" цикла событий Node.js, после операций ввода-вывода и до таймеров.

```javascript
console.log("Начало")

// Макрозадача (выполнится позже)
setTimeout(() => {
  console.log("setTimeout")
}, 0)

// Специальная микрозадача в Node.js (выполнится первой среди асинхронных)
process.nextTick(() => {
  console.log("nextTick")
})

// Микрозадача (выполнится сразу после nextTick)
Promise.resolve().then(() => {
  console.log("Promise")
})

// Макрозадача специфичная для Node.js
setImmediate(() => {
  console.log("setImmediate")
})

console.log("Конец")

// Вывод в Node.js:
// Начало
// Конец
// nextTick
// Promise
// setTimeout  (порядок setTimeout и setImmediate может варьироваться)
// setImmediate
```

## Сравнительная таблица

| **Характеристики**       | **Макрозадачи (Macrotasks)**                           | **Микрозадачи (Microtasks)**                                    |
| ------------------------ | ------------------------------------------------------ | --------------------------------------------------------------- |
| **Приоритет выполнения** | Низкий                                                 | Высокий                                                         |
| **Порядок обработки**    | По одной за итерацию цикла событий                     | Все из очереди перед следующей макрозадачей                     |
| **Типичные источники**   | setTimeout, setInterval, I/O, DOM события              | Promise, queueMicrotask, process.nextTick                       |
| **Цель использования**   | Планирование длительных или менее приоритетных задач   | Обеспечение последовательности для логически связанных операций |
| **Влияние на UI**        | Позволяют браузеру обновить отображение между задачами | Могут блокировать UI, если их много                             |

## Практическое применение знаний о микро- и макрозадачах

### 1. Оптимизация отзывчивости UI

```javascript
// Разбиение крупной задачи на части с помощью макрозадач
function processLargeDataset(data, chunkSize = 1000) {
  let index = 0

  function processChunk() {
    const chunk = data.slice(index, index + chunkSize)

    if (chunk.length === 0) return

    // Обработка части данных
    for (const item of chunk) {
      // Какая-то обработка
      processItem(item)
    }

    index += chunkSize

    // Запланировать обработку следующей части
    setTimeout(processChunk, 0)
  }

  processChunk()
}
```

### 2. Обеспечение последовательности зависимых асинхронных операций

```javascript
// Использование микрозадач для гарантии определенного порядка выполнения
function updateUserData(userId) {
  let userData

  // Цепочка микрозадач обеспечивает последовательность
  fetchUserData(userId)
    .then((data) => {
      userData = data
      return validateUserData(userData)
    })
    .then((isValid) => {
      if (isValid) {
        return saveUserDataToDatabase(userData)
      }
      throw new Error("Invalid user data")
    })
    .then(() => {
      console.log("User data updated successfully")
    })
    .catch((error) => {
      console.error("Error updating user data:", error)
    })
}
```

## Заключение

Понимание различий между microtasks и macrotasks критически важно при разработке асинхронного JavaScript-кода:

- **Микрозадачи** имеют более высокий приоритет и используются для операций, которые должны выполняться быстро после текущего кода, например, для обработки результатов промисов.
- **Макрозадачи** выполняются между отрисовками интерфейса (в браузерах) и подходят для более тяжелых или менее приоритетных операций.

Неправильное использование очередей задач может привести к таким проблемам, как блокировка интерфейса или непредсказуемый порядок выполнения кода. Поэтому понимание принципов работы Event Loop и разницы между типами задач является фундаментальным аспектом JavaScript-разработки.

---

[[002 Node.js|Назад]]
