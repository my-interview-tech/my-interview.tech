---
title: Что делает метод .then() .catch() и .finally()
draft: false
tags:
  - "#JavaScript"
  - "#NodeJS"
  - "#промисы"
  - "#promises"
  - "#асинхронность"
info:
  - https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Promise
  - https://learn.javascript.ru/promise-chaining
  - https://nodejs.org/dist/latest-v18.x/docs/api/util.html#promises
---

Методы `.then()`, `.catch()` и `.finally()` используются для работы с Promise (промисами) в JavaScript и Node.js. Они представляют собой способ обработки асинхронных операций.

## Метод .then()

**Метод `.then()`** используется для обработки успешно выполненного промиса (в состоянии "fulfilled"). Он принимает два необязательных аргумента:

1. **onFulfilled** - функция, которая вызывается при успешном выполнении промиса
2. **onRejected** - функция, которая вызывается при отклонении промиса (необязательный параметр)

```javascript
promise.then(
  (result) => console.log(result), // обработка успешного выполнения
  (error) => console.error(error), // обработка ошибки (опционально)
)
```

Метод `.then()` также возвращает новый промис, что позволяет строить цепочки вызовов:

```javascript
fetch("https://api.example.com/data")
  .then((response) => response.json())
  .then((data) => console.log(data))
```

## Метод .catch()

**Метод `.catch()`** используется для обработки отклоненных промисов (в состоянии "rejected"). Это синтаксический сахар для `.then(null, onRejected)`:

```javascript
promise.catch((error) => console.error(error))

// Аналогично:
promise.then(null, (error) => console.error(error))
```

Метод `.catch()` перехватывает ошибки как в самом промисе, так и в обработчиках `.then()`. Это делает его удобным для централизованной обработки ошибок:

```javascript
fetchData()
  .then(processData)
  .then(saveData)
  .catch((error) => {
    // Обрабатывает ошибки из fetchData, processData и saveData
    console.error("Произошла ошибка:", error)
  })
```

## Метод .finally()

**Метод `.finally()`** выполняет указанный код независимо от того, выполнен промис успешно или отклонен. Это полезно для очистки ресурсов, закрытия соединений и т.д.:

```javascript
let connection

db.connect()
  .then((conn) => {
    connection = conn
    return connection.query("SELECT * FROM users")
  })
  .then((results) => processResults(results))
  .catch((error) => handleError(error))
  .finally(() => {
    // Выполнится всегда, независимо от успеха или ошибки
    if (connection) connection.close()
  })
```

Особенности `.finally()`:

- Не принимает аргументов (результат промиса игнорируется)
- Не изменяет результат промиса (прозрачно передает его дальше)
- Может быть использован как в успешных, так и в отклоненных случаях

## Пример комплексного использования в Node.js:

```javascript
const fs = require("fs").promises

fs.readFile("config.json", "utf8")
  .then((data) => {
    const config = JSON.parse(data)
    return fetch(`https://api.example.com/data?apiKey=${config.apiKey}`)
  })
  .then((response) => {
    if (!response.ok) {
      throw new Error(`HTTP error! Status: ${response.status}`)
    }
    return response.json()
  })
  .then((data) => {
    console.log("Полученные данные:", data)
    return fs.writeFile("result.json", JSON.stringify(data))
  })
  .catch((error) => {
    console.error("Произошла ошибка:", error)
  })
  .finally(() => {
    console.log("Операция завершена")
  })
```

В этом примере показано, как методы `.then()`, `.catch()` и `.finally()` используются вместе в типичном асинхронном Node.js-коде.

---

[[003 JSCore|Назад]]
