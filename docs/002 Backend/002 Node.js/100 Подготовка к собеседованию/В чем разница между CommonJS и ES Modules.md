---
title: В чем разница между CommonJS и ES Modules
draft: false
tags:
  - "#NodeJS"
  - "#JavaScript"
  - "#модули"
  - "#CommonJS"
  - "#ESModules"
  - "#импорт"
info:
  - "[Документация Node.js о модулях](https://nodejs.org/api/modules.html)"
  - "[Документация MDN о модулях ES](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Modules)"
  - "[JavaScript.info: Модули](https://javascript.info/modules-intro)"
---

# Разница между CommonJS и ES Modules

`CommonJS` и `ES Modules` (ESM) — это две системы модулей в JavaScript, каждая из которых имеет свои особенности и подходы к импорту и экспорту кода. Вот основные различия между ними:

## 1. Синтаксис импорта и экспорта

### CommonJS (CJS):

Использует `require()` для импорта модулей и `module.exports` для экспорта.

```javascript
// Экспорт в CommonJS
module.exports = function () {
  console.log("Hello from CommonJS")
}

// Импорт в CommonJS
const myModule = require("./myModule")
myModule()
```

### ES Modules (ESM):

Использует ключевые слова `import` и `export` для работы с модулями.

```javascript
// Экспорт в ES Modules
export function greet() {
  console.log("Hello from ES Modules")
}

// Импорт в ES Modules
import { greet } from "./myModule.js"
greet()
```

## 2. Синхронность и асинхронность

### CommonJS:

Импорт и экспорт происходят **синхронно**, то есть весь код выполняется немедленно при загрузке модуля. Это означает, что если модуль имеет какие-то вычисления, они выполняются сразу при загрузке модуля.

### ES Modules:

Импорт и экспорт происходят **асинхронно**. Это позволяет браузерам и средам выполнения (таким как Node.js) оптимизировать загрузку и выполнение, отложив импорт модулей до того момента, когда они реально понадобятся. Это также помогает избежать циклических зависимостей.

## 3. Поддержка в Node.js

### CommonJS:

Является основной системой модулей в Node.js с момента его создания. Node.js поддерживает `CommonJS` из коробки, и это используется для большинства модулей в экосистеме npm.

### ES Modules:

В Node.js **поддержка ES Modules появилась с версии 12**, но с ограничениями. Для работы с ESM в Node.js нужно либо использовать расширение `.mjs`, либо в файле `package.json` указать `"type": "module"`. Важно, что модули в ESM не могут работать с `require()` и `module.exports`, и наоборот.

## 4. Механизм экспорта

### CommonJS:

Экспортируются **все объекты** (функции, объекты, массивы и т. д.), которые присваиваются свойству `module.exports`. Если присвоить новое значение, старое заменяется.

### ES Modules:

Используют **именные экспорты** и **экспорт по умолчанию**. Экспорт по умолчанию позволяет экспортировать один основной элемент, а именные экспорты — несколько.

```javascript
// Экспорт по умолчанию (ESM)
export default function greet() {
  console.log("Hello")
}
```

## 5. Циклические зависимости

### CommonJS:

Если два модуля зависят друг от друга, то в случае циклической зависимости `require()` возвращает **частичный результат** (неполный объект), что может привести к неожиданным результатам.

### ES Modules:

Они **обрабатывают циклические зависимости** правильно, потому что модули загружаются асинхронно. При циклической зависимости, экспортированные значения модуля всегда возвращаются в "состоянии завершённости", т. е. они будут актуальными на момент использования.

## 6. Гибкость

### CommonJS:

Позволяет динамически использовать `require()` в любом месте кода, даже в условиях циклических зависимостей или внутри условий.

### ES Modules:

`import` всегда используется в верхней части модуля (на уровне самого модуля), и нельзя вызывать `import` внутри условий или циклов. Это помогает делать код более предсказуемым и оптимизированным для инструментов сборки.

## 7. Поддержка в браузерах

### CommonJS:

Не поддерживается напрямую в браузерах, так как требует трансляции (например, с помощью Webpack или Browserify) для работы в браузерах.

### ES Modules:

**Поддерживаются нативно** во всех современных браузерах. Это делает ESM предпочтительным для использования в фронтенд-разработке.

## 8. Импорт всего модуля

### CommonJS:

Можно импортировать весь модуль как объект.

```javascript
const myModule = require("./myModule")
```

### ES Modules:

Использует `import * as` для импорта всего модуля как объекта.

```javascript
import * as myModule from "./myModule.js"
```

## 9. Поддержка динамического импорта

### CommonJS:

Поддерживает динамическое подключение модулей через `require()`, но это всегда синхронный процесс.

### ES Modules:

Поддерживает **динамический импорт** с помощью `import()`, который возвращает **Promise** и может быть использован асинхронно.

```javascript
import("./myModule.js").then((module) => {
  module.greet()
})
```

## Примеры кода

### CommonJS

```javascript
// module.js
module.exports.greet = function () {
  console.log("Hello from CommonJS")
}

// app.js
const { greet } = require("./module")
greet()
```

### ES Modules

```javascript
// module.js
export function greet() {
  console.log("Hello from ES Modules")
}

// app.js
import { greet } from "./module.js"
greet()
```

## Заключение

- **CommonJS** более зрелая и широко используемая система модулей, которая идеально подходит для серверных приложений, таких как Node.js.
- **ES Modules** представляют собой современную систему модулей, оптимизированную для работы в браузерах и Node.js. В отличие от CommonJS, ESM поддерживает асинхронную загрузку модулей и предлагает более строгую и предсказуемую модель импорта и экспорта.

При выборе между CommonJS и ES Modules следует учитывать контекст (сервер vs браузер), поддержку в Node.js и предпочтения по стилю кода.

---

[[002 Node.js|Назад]]
