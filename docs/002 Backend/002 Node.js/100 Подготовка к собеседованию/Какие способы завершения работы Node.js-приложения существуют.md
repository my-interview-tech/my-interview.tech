---
title: Какие способы завершения работы Node.js-приложения существуют
draft: false
tags:
  - "#NodeJS"
  - "#процесс"
  - "#завершение-работы"
  - "#сигналы"
  - "#graceful-shutdown"
info:
  - "[Документация Node.js по Process](https://nodejs.org/api/process.html)"
  - "[Graceful shutdown в Node.js](https://blog.heroku.com/best-practices-nodejs-errors)"
  - "[Обработка сигналов в Node.js](https://nodejs.org/api/process.html#process_signal_events)"
---

# Способы завершения работы Node.js-приложения

В Node.js существует несколько способов завершения работы приложения. Выбор конкретного метода зависит от ситуации — от простого завершения до обработки ошибок и завершения асинхронных операций.

## 1. process.exit()

Это самый прямой способ завершить выполнение Node.js-приложения. Он немедленно завершает процесс с заданным кодом выхода.

**Синтаксис**: `process.exit([код_выхода])`

- `код_выхода` (необязательный параметр) — целое число, указывающее на код завершения процесса
- `0` — нормальное завершение (используется по умолчанию)
- Ненулевой код (например, `1`) — указывает на ошибку

**Пример**:

```javascript
console.log("Приложение завершится через 3 секунды")

setTimeout(() => {
  console.log("Завершаем процесс")
  process.exit(0) // Завершаем приложение с кодом 0 (нормальное завершение)
}, 3000)
```

**Важное замечание**: `process.exit()` немедленно завершает процесс, прерывая все текущие операции, включая асинхронные задачи и незавершенные соединения.

## 2. Естественное завершение

Если все асинхронные операции и потоки завершены, Node.js автоматически завершит процесс. Это происходит, когда:

- Выполнение всего синхронного кода в файле завершено
- В цикле событий (event loop) больше нет задач для выполнения
- Нет активных таймеров, сетевых соединений, файловых операций

**Пример**:

```javascript
// Простой скрипт, который завершится автоматически после выполнения
console.log("Начало выполнения")

// Асинхронная операция
setTimeout(() => {
  console.log("Таймер выполнен")
  // После этого, если нет других активных операций, программа завершится
}, 1000)

console.log("Продолжение выполнения")
// Когда все операции завершены, Node.js автоматически закроет процесс
```

## 3. Обработка сигналов операционной системы

Node.js позволяет перехватывать сигналы, которые посылаются операционной системой. Это полезно для корректного завершения работы, например, при нажатии Ctrl+C в терминале или отправке сигнала от внешней системы.

### Обработка сигнала SIGINT (Ctrl+C)

```javascript
process.on("SIGINT", () => {
  console.log("Получен сигнал SIGINT. Завершаем процесс...")

  // Здесь можно выполнить очистку ресурсов
  closeConnections()
  flushLogs()

  process.exit(0)
})

function closeConnections() {
  console.log("Закрытие активных соединений...")
  // Логика закрытия соединений
}

function flushLogs() {
  console.log("Сохранение логов...")
  // Логика сохранения логов
}
```

### Обработка сигнала SIGTERM

```javascript
process.on("SIGTERM", () => {
  console.log("Получен сигнал SIGTERM. Завершаем процесс...")

  // Плавное завершение работы
  gracefulShutdown()
    .then(() => process.exit(0))
    .catch((err) => {
      console.error("Ошибка при завершении:", err)
      process.exit(1)
    })
})

async function gracefulShutdown() {
  // Закрытие соединений с базой данных, API и т.д.
}
```

## 4. process.exitCode

Этот метод позволяет задать код завершения, который будет использован при завершении процесса. В отличие от `process.exit()`, вызов `process.exitCode` не завершает процесс сразу, а только устанавливает код завершения для использования при нормальном завершении.

```javascript
process.exitCode = 1 // Устанавливаем код ошибки
console.log("Процесс завершится с кодом 1 после выполнения всех задач")

// Продолжается выполнение программы
// Когда все операции завершатся, процесс выйдет с кодом 1
```

## 5. Необработанные исключения

Если в вашем приложении возникает необработанная ошибка, Node.js завершит процесс с кодом ошибки (по умолчанию с кодом `1`).

```javascript
// Необработанная ошибка приведет к завершению процесса
setTimeout(() => {
  throw new Error("Что-то пошло не так")
}, 1000)
```

Лучшей практикой является обработка таких ошибок:

```javascript
process.on("uncaughtException", (err) => {
  console.error("Необработанное исключение:", err)

  // Выполнение необходимых операций перед завершением
  // Важно: после uncaughtException состояние приложения может быть некорректным
  // Рекомендуется завершить процесс после логирования ошибки

  process.exit(1)
})
```

## 6. Асинхронное завершение с setImmediate() и setTimeout()

Иногда требуется выполнить несколько действий до завершения работы приложения. Это можно сделать с использованием `setImmediate()` или `setTimeout()`. Эти методы позволяют завершить процесс после выполнения оставшихся асинхронных операций.

```javascript
setImmediate(() => {
  console.log("Завершаем работу после выполнения оставшихся асинхронных задач")

  // Очистка ресурсов
  cleanupResources()

  process.exit(0)
})

function cleanupResources() {
  // Закрытие соединений, файловых дескрипторов и т.д.
}
```

## 7. Плавное завершение с Promise и async/await

Если в приложении используются Promise или асинхронные функции, можно дождаться их выполнения перед завершением работы.

```javascript
async function shutdown() {
  console.log("Начинаем процесс завершения работы...")

  try {
    // Закрытие HTTP-сервера (если есть)
    await closeHttpServer()

    // Закрытие соединений с базой данных
    await closeDbConnections()

    // Ожидание завершения фоновых задач
    await waitForBackgroundTasks()

    console.log("Все задачи завершены. Закрываем приложение")
    process.exit(0)
  } catch (error) {
    console.error("Ошибка при завершении работы:", error)
    process.exit(1)
  }
}

// Пример запуска процесса завершения работы
process.on("SIGINT", shutdown)
```

## Рекомендации по правильному завершению работы

1. **Используйте плавное завершение** для серверных приложений:

   - Прекратите прием новых запросов/соединений
   - Дождитесь завершения текущих запросов
   - Закройте соединения с базами данных и внешними сервисами
   - Сохраните все необходимые данные

2. **Обрабатывайте сигналы** для корректного завершения при внешнем воздействии:

   - SIGINT (Ctrl+C)
   - SIGTERM (сигнал завершения, часто используется в контейнерах)
   - SIGHUP (закрытие терминала)

3. **Устанавливайте таймауты** для предотвращения "зависания" при завершении:

   ```javascript
   function shutdownWithTimeout(timeout = 5000) {
     const forceExit = setTimeout(() => {
       console.warn(`Превышен таймаут завершения (${timeout}ms), принудительный выход`)
       process.exit(1)
     }, timeout)

     // Очистка таймаута, если процесс завершится нормально
     forceExit.unref()

     gracefulShutdown()
       .then(() => process.exit(0))
       .catch((err) => {
         console.error("Ошибка при завершении:", err)
         process.exit(1)
       })
   }
   ```

## Заключение

Выбор способа завершения приложения зависит от конкретного сценария и требований:

- Используйте `process.exit()` для простых скриптов или когда требуется немедленное завершение
- Реализуйте плавное завершение для серверных приложений с активными соединениями
- Обрабатывайте сигналы операционной системы для корректной реакции на внешние события
- Учитывайте возможность необработанных исключений

Правильное завершение работы приложения особенно важно для серверных приложений, чтобы избежать потери данных, недоступности сервиса или повреждения ресурсов.

---

[[002 Node.js|Назад]]
