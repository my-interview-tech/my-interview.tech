---
title: В чем разница между стрелочными функциями и обычными функциями в JavaScript
draft: false
tags:
  - "#NodeJS"
  - "#JavaScript"
  - "#функции"
  - "#ES6"
  - "#стрелочные-функции"
  - "#this"
info:
  - "[MDN: Стрелочные функции](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Functions/Arrow_functions)"
  - "[MDN: Функции в JavaScript](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Functions)"
  - "[JavaScript.info: Стрелочные функции](https://javascript.info/arrow-functions-basics)"
---

# Разница между стрелочными функциями и обычными функциями в JavaScript

Стрелочные функции (`=>`) были введены в ES6 (ECMAScript 2015) и представляют собой более краткий синтаксис для объявления функций. Однако, помимо синтаксических различий, они имеют ряд фундаментальных отличий от обычных функций, которые важно понимать для правильного использования.

## 1. Синтаксис

**Обычные функции** объявляются с использованием ключевого слова `function`:

```javascript
// Объявление функции
function sum(a, b) {
  return a + b
}

// Функциональное выражение
const multiply = function (a, b) {
  return a * b
}
```

**Стрелочные функции** используют синтаксис `=>`:

```javascript
// Стрелочная функция (полная форма)
const sum = (a, b) => {
  return a + b
}

// Сокращенная форма для простых выражений
const multiply = (a, b) => a * b

// Без параметров
const greet = () => "Привет, мир!"

// С одним параметром (скобки необязательны)
const square = (x) => x * x
```

## 2. Контекст `this`

Одно из ключевых отличий стрелочных функций заключается в том, как они обрабатывают контекст `this`.

### Обычные функции

Обычные функции имеют свой собственный контекст `this`, который зависит от того, как функция вызывается:

```javascript
function Person() {
  this.age = 0

  setInterval(function () {
    // `this` здесь указывает на глобальный объект (или undefined в строгом режиме),
    // а не на экземпляр Person
    this.age++
    console.log(this.age) // NaN, потому что `this` не тот, что ожидается
  }, 1000)
}

const person = new Person()
```

### Стрелочные функции

Стрелочные функции **не имеют своего собственного `this`**. Они наследуют значение `this` из родительской области видимости:

```javascript
function Person() {
  this.age = 0

  setInterval(() => {
    // `this` здесь указывает на экземпляр Person, т.к. унаследован
    this.age++
    console.log(this.age) // правильно увеличивает и выводит возраст
  }, 1000)
}

const person = new Person()
```

## 3. Аргументы (arguments)

### Обычные функции

Обычные функции имеют доступ к специальному объекту `arguments`, который содержит все переданные аргументы:

```javascript
function logArgs() {
  console.log(arguments)
}

logArgs(1, 2, 3) // выводит объект, содержащий [1, 2, 3]
```

### Стрелочные функции

Стрелочные функции **не имеют собственного объекта `arguments`**. Они наследуют `arguments` из родительской области видимости, если она доступна:

```javascript
const logArgs = () => {
  console.log(arguments) // ошибка или унаследует из родительской области
}

// Вместо этого рекомендуется использовать rest параметры
const logArgs2 = (...args) => {
  console.log(args)
}

logArgs2(1, 2, 3) // выводит массив [1, 2, 3]
```

## 4. Ключевое слово `new`

### Обычные функции

Обычные функции могут быть использованы как конструкторы с ключевым словом `new`:

```javascript
function Person(name) {
  this.name = name
}

const john = new Person("John") // работает
console.log(john.name) // "John"
```

### Стрелочные функции

Стрелочные функции **не могут быть использованы как конструкторы**:

```javascript
const Person = (name) => {
  this.name = name
}

const john = new Person("John") // TypeError: Person is not a constructor
```

## 5. Методы `call()`, `apply()` и `bind()`

### Обычные функции

В обычных функциях методы `call()`, `apply()` и `bind()` могут изменять значение `this`:

```javascript
function greet() {
  console.log(`Привет, меня зовут ${this.name}`)
}

const person = { name: "Иван" }
greet.call(person) // "Привет, меня зовут Иван"
```

### Стрелочные функции

В стрелочных функциях значение `this` **нельзя изменить** с помощью `call()`, `apply()` или `bind()`:

```javascript
const greet = () => {
  console.log(`Привет, меня зовут ${this.name}`)
}

const person = { name: "Иван" }
greet.call(person) // Не изменит this, выведет "Привет, меня зовут undefined"
```

## 6. Оператор `yield`

### Обычные функции

Обычные функции могут быть генераторами с использованием оператора `yield`:

```javascript
function* generateSequence() {
  yield 1
  yield 2
  return 3
}

const generator = generateSequence()
```

### Стрелочные функции

Стрелочные функции **не могут быть генераторами**:

```javascript
const generateSequence = *() => { // SyntaxError
  yield 1;
  yield 2;
  return 3;
};
```

## 7. Прототип (prototype)

### Обычные функции

Обычные функции имеют свойство `prototype`, которое используется при создании объектов с помощью `new`:

```javascript
function Person() {}
Person.prototype.greet = function () {
  console.log("Привет!")
}

const person = new Person()
person.greet() // "Привет!"
```

### Стрелочные функции

Стрелочные функции **не имеют свойства `prototype`**:

```javascript
const Person = () => {}
console.log(Person.prototype) // undefined
```

## Когда использовать стрелочные функции

Стрелочные функции лучше всего подходят для:

1. **Коротких анонимных функций**, особенно в колбэках:

   ```javascript
   const numbers = [1, 2, 3]
   const squared = numbers.map((x) => x * x)
   ```

2. **Функций, где важно сохранить контекст `this`**:

   ```javascript
   class Timer {
     constructor() {
       this.seconds = 0
       setInterval(() => this.tick(), 1000)
     }

     tick() {
       this.seconds++
     }
   }
   ```

## Когда использовать обычные функции

Обычные функции лучше всего подходят для:

1. **Методов объекта**, где `this` должен ссылаться на объект:

   ```javascript
   const calculator = {
     value: 0,
     add(a) {
       this.value += a
     },
   }
   ```

2. **Конструкторов** для создания объектов с помощью `new`

3. **Генераторов** с использованием `yield`

4. **Случаев, когда нужен собственный объект `arguments`**

## Сравнительная таблица

| **Характеристика**        | **Обычные функции** | **Стрелочные функции**            |
| ------------------------- | ------------------- | --------------------------------- |
| **Синтаксис**             | `function() {}`     | `() => {}`                        |
| **this**                  | Имеют свой контекст | Наследуют из родительской области |
| **arguments**             | Доступен            | Не доступен (наследуется)         |
| **new оператор**          | Можно использовать  | Нельзя использовать               |
| **call/apply/bind**       | Изменяет this       | Не изменяет this                  |
| **yield**                 | Поддерживается      | Не поддерживается                 |
| **prototype**             | Есть                | Нет                               |
| **Сокращенный синтаксис** | Нет                 | Есть                              |

## Заключение

Стрелочные функции предлагают более компактный синтаксис и лексический `this`, что делает их идеальными для коротких колбэков и функций, где важно сохранить контекст. Обычные функции остаются необходимыми для методов объектов, конструкторов и других случаев, где требуется динамический `this` или специфические функциональные возможности.

Выбор между стрелочными и обычными функциями должен основываться на понимании их различий и требованиях конкретной задачи.

---

[[002 Node.js|Назад]]
