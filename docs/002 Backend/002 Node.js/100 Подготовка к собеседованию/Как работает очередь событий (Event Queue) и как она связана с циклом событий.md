---
title: Как работает очередь событий (Event Queue) и как она связана с циклом событий
draft: false
tags:
  - "#NodeJS"
  - "#JavaScript"
  - "#асинхронность"
  - "#event_loop"
  - "#event_queue"
  - "#микрозадачи"
info:
  - "[Документация Node.js по Event Loop](https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/)"
  - "[MDN Web Docs: Цикл событий](https://developer.mozilla.org/ru/docs/Web/JavaScript/EventLoop)"
  - "[Understanding the Node.js Event Loop](https://nodejs.dev/learn/the-nodejs-event-loop)"
---

Очередь событий (Event Queue) — это механизм в Node.js и браузерном JavaScript, который хранит события и задачи, ожидающие обработки циклом событий (Event Loop). Этот механизм играет ключевую роль в обеспечении неблокирующего, асинхронного выполнения кода JavaScript.

## Очередь событий (Event Queue)

Очередь событий — это структура данных, которая работает по принципу FIFO (First In, First Out), то есть события обрабатываются в том порядке, в котором они были добавлены в очередь.

В Node.js существует несколько разных очередей событий:

1. **Очередь таймеров** — хранит коллбэки, запланированные через `setTimeout()` и `setInterval()`
2. **Очередь ввода/вывода (I/O)** — коллбэки операций с файловой системой, сетью и т.д.
3. **Очередь проверки (Check)** — коллбэки, запланированные через `setImmediate()`
4. **Очередь закрытия (Close)** — коллбэки, вызываемые при закрытии ресурсов (например, сокетов)
5. **Очередь микрозадач** — содержит промисы (`Promise`) и `process.nextTick()`

## Цикл событий (Event Loop)

Цикл событий — это бесконечный цикл в Node.js, который отвечает за:

1. Выполнение кода JavaScript
2. Обработку асинхронных операций
3. Обработку событий ввода/вывода
4. Выполнение коллбэков из очереди

### Схема работы цикла событий:

```
   ┌───────────────────────────┐
┌─>│           timers          │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │     pending callbacks     │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
│  │       idle, prepare       │
│  └─────────────┬─────────────┘      ┌───────────────┐
│  ┌─────────────┴─────────────┐      │   incoming:   │
│  │           poll            │<─────┤  connections, │
│  └─────────────┬─────────────┘      │   data, etc.  │
│  ┌─────────────┴─────────────┐      └───────────────┘
│  │           check           │
│  └─────────────┬─────────────┘
│  ┌─────────────┴─────────────┐
└──┤      close callbacks      │
   └───────────────────────────┘
```

## Связь очереди событий с циклом событий

1. **Инициализация**:

   - JavaScript-код начинает выполняться синхронно
   - Асинхронные операции передаются Node.js API / Web API

2. **Добавление в очередь**:

   - Когда асинхронная операция завершается, её коллбэк добавляется в соответствующую очередь

3. **Выполнение**:
   - Цикл событий проверяет стек вызовов (Call Stack)
   - Если стек пуст, цикл берет задачу из очереди и добавляет в стек для выполнения
   - После выполнения коллбэка, стек очищается и цикл продолжается

## Пример работы очереди событий

```javascript
console.log("Начало программы") // 1

setTimeout(() => {
  console.log("Таймер на 0 мс") // 4
}, 0)

Promise.resolve().then(() => {
  console.log("Промис выполнен") // 3
})

console.log("Конец программы") // 2
```

### Объяснение:

1. `console.log("Начало программы")` выполняется синхронно.
2. `setTimeout` регистрирует коллбэк в очереди таймеров.
3. `Promise.resolve().then()` добавляет коллбэк в очередь микрозадач.
4. `console.log("Конец программы")` выполняется синхронно.
5. Стек вызовов пустеет, и цикл событий проверяет очереди:
   - Сначала обрабатывается очередь микрозадач — выводится "Промис выполнен"
   - Затем обрабатывается очередь таймеров — выводится "Таймер на 0 мс"

## Порядок обработки очередей в Node.js

Цикл событий в Node.js обрабатывает очереди в следующем порядке:

1. Микрозадачи (`process.nextTick()` имеет приоритет над Promise)
2. Таймеры (`setTimeout()`, `setInterval()`)
3. Ожидающие коллбэки ввода/вывода
4. Опрос (poll) — ввод/вывод и новые события
5. Проверка (`setImmediate()`)
6. Коллбэки закрытия ресурсов

Эта последовательность выполняется циклически, позволяя Node.js эффективно обрабатывать асинхронные операции без блокировки.

---

[[002 Node.js|Назад]]
