---
title: Что произойдёт если в setTimeout() передать отрицательное значение задержки
draft: false
tags:
  - "#NodeJS"
  - "#setTimeout"
  - "#event-loop"
  - "#асинхронность"
  - "#таймеры"
  - "#JavaScript"
info:
  - https://nodejs.org/api/timers.html#settimeoutcallback-delay-args
  - https://developer.mozilla.org/en-US/docs/Web/API/setTimeout
  - https://html.spec.whatwg.org/multipage/timers-and-user-prompts.html#timers
---

# Что произойдёт если в setTimeout() передать отрицательное значение задержки

Если в функцию `setTimeout()` передать отрицательное значение задержки (delay), это значение **будет автоматически преобразовано в 0**. Это поведение стандартизировано и одинаково работает как в Node.js, так и в браузерах.

## Как обрабатываются отрицательные значения задержки

### Спецификация HTML

Согласно спецификации HTML:

> Если задержка меньше 0, то она устанавливается в 0.

Это означает, что следующие вызовы эквивалентны:

```javascript
setTimeout(callback, -1000)
setTimeout(callback, -1)
setTimeout(callback, 0)
```

Все они приведут к выполнению колбэка в ближайшее возможное время после завершения текущего синхронного кода.

## Пример с отрицательной задержкой

```javascript
console.log("Начало")

setTimeout(() => {
  console.log("Таймер с отрицательной задержкой (-100)")
}, -100)

console.log("Конец")
```

Результат выполнения:

```
Начало
Конец
Таймер с отрицательной задержкой (-100)
```

Колбэк выполняется после завершения синхронного кода, как если бы задержка была равна 0.

## Порядок выполнения в Event Loop

Важно понимать, что даже при нулевой задержке, `setTimeout(fn, 0)` не выполняет функцию мгновенно. Вместо этого, функция добавляется в очередь таймеров (timer queue) и будет выполнена на следующей итерации Event Loop.

### Демонстрация порядка выполнения

```javascript
console.log("1. Синхронный код")

setTimeout(() => {
  console.log("4. setTimeout с задержкой -1")
}, -1)

Promise.resolve().then(() => {
  console.log("3. Promise (микрозадача)")
})

process.nextTick(() => {
  console.log("2. process.nextTick()")
})

console.log("1. Синхронный код (окончание)")
```

Результат выполнения в Node.js:

```
1. Синхронный код
1. Синхронный код (окончание)
2. process.nextTick()
3. Promise (микрозадача)
4. setTimeout с задержкой -1
```

## Схема выполнения в Event Loop

```
┌───────────────────────────┐
│        Синхронный код     │
└─────────────┬─────────────┘
              ↓
┌─────────────┴─────────────┐
│     process.nextTick()    │
└─────────────┬─────────────┘
              ↓
┌─────────────┴─────────────┐
│      Микрозадачи          │
│    (Promise, queueMicrotask)│
└─────────────┬─────────────┘
              ↓
┌─────────────┴─────────────┐
│     setTimeout(fn, -1)    │ ← расположен здесь независимо
│     setTimeout(fn, 0)     │   от отрицательного значения
└───────────────────────────┘
```

## Практические следствия

### 1. Минимальная задержка

```javascript
console.time("минимальная задержка")
setTimeout(() => {
  console.timeEnd("минимальная задержка")
}, -9999) // Отрицательное значение
```

Результат может показать задержку от 1 до 4 мс даже с отрицательным значением, что подтверждает преобразование в 0.

### 2. Сравнение с setImmediate()

В Node.js существует также функция `setImmediate()`, которая иногда может выполниться раньше, чем `setTimeout(fn, 0)`:

```javascript
// Этот порядок может варьироваться в зависимости от нагрузки
setTimeout(() => console.log("setTimeout с задержкой -1"), -1)
setImmediate(() => console.log("setImmediate"))
```

В некоторых случаях `setImmediate` может выполниться раньше, потому что он привязан к фазе check в Event Loop, которая может наступить раньше следующей итерации таймеров.

### 3. Реальные сценарии использования минимальной задержки

Отрицательные значения в `setTimeout()` не имеют практического применения, однако `setTimeout(fn, 0)` часто используется для:

- Разделения тяжелых вычислений на части
- Выполнения кода после рендеринга в браузерах
- Переноса кода в асинхронный контекст

```javascript
// Разделение тяжелой обработки
function processLargeArray(array, callback) {
  const chunk = 1000
  let index = 0

  function processChunk() {
    const end = Math.min(index + chunk, array.length)

    // Обработка части массива
    for (let i = index; i < end; i++) {
      array[i] = array[i] * 2
    }

    index = end

    if (index < array.length) {
      setTimeout(processChunk, 0) // Можно использовать и отрицательное значение
    } else {
      callback(array)
    }
  }

  processChunk()
}
```

## Минимальная задержка в браузерах

В браузерах есть дополнительное ограничение на минимальную задержку `setTimeout()`. Согласно спецификации HTML, минимальная задержка для вложенных таймеров может составлять 4 мс и более. Это ограничение не применяется к отрицательным значениям особым образом — они всё равно преобразуются в 0, а затем применяется стандартное ограничение.

## Заключение

Если в `setTimeout()` передать отрицательное значение задержки:

1. Оно будет автоматически преобразовано в 0
2. Колбэк будет выполнен на следующей итерации Event Loop после завершения текущего кода
3. Выполнение произойдет после обработки микрозадач (Promise, queueMicrotask) и колбэков process.nextTick()
4. Практической разницы между setTimeout(fn, -100) и setTimeout(fn, 0) нет

Понимание этого поведения важно для правильной работы с асинхронным кодом и Event Loop в JavaScript.

---

[[003 JSCore|Назад]]
