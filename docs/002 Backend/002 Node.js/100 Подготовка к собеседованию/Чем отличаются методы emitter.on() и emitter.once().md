---
title: Чем отличаются методы emitter.on() и emitter.once()
draft: false
tags:
  - "#NodeJS"
  - "#EventEmitter"
  - "#события"
  - "#обработчики"
  - "#асинхронность"
  - "#паттерны"
info:
  - https://nodejs.org/api/events.html#emitteroneventname-listener
  - https://nodejs.org/api/events.html#emitteronceeventname-listener
  - https://habr.com/ru/articles/359896/
---

# Чем отличаются методы emitter.on() и emitter.once()

Методы `emitter.on()` и `emitter.once()` в Node.js используются для подписки на события в системе событий EventEmitter, но имеют принципиальное отличие в количестве и времени вызовов обработчика.

## Основные отличия

| Характеристика                      | **emitter.on()**     | **emitter.once()**                 |
| ----------------------------------- | -------------------- | ---------------------------------- |
| Количество вызовов                  | Многократно          | Только один раз                    |
| Автоматическое удаление обработчика | Нет                  | Да, после первого вызова           |
| Сценарий использования              | Многократные события | Однократные события, инициализация |

## Метод emitter.on()

Метод `emitter.on(eventName, listener)` добавляет функцию `listener` в конец массива слушателей для события `eventName`. Этот обработчик будет вызываться **каждый раз**, когда происходит событие с указанным именем.

### Синтаксис

```javascript
emitter.on(eventName, listener)
```

### Пример использования

```javascript
const EventEmitter = require("events")
const emitter = new EventEmitter()

// Создаем обработчик, который будет вызываться многократно
emitter.on("data", (data) => {
  console.log("Получены данные:", data)
})

// Генерируем событие несколько раз
emitter.emit("data", "первый пакет") // Получены данные: первый пакет
emitter.emit("data", "второй пакет") // Получены данные: второй пакет
emitter.emit("data", "третий пакет") // Получены данные: третий пакет
```

### Характеристики on()

1. **Сохранение обработчика**: Обработчик остается активным и реагирует на каждое возникновение события
2. **Порядок вызова**: Обработчики вызываются в том порядке, в котором они были добавлены
3. **Возвращаемое значение**: Возвращает ссылку на сам EmitterObject для поддержки цепочки вызовов

## Метод emitter.once()

Метод `emitter.once(eventName, listener)` добавляет **одноразовый** обработчик для указанного события. Этот обработчик будет вызван только один раз, когда событие произойдет, а затем будет автоматически удален.

### Синтаксис

```javascript
emitter.once(eventName, listener)
```

### Пример использования

```javascript
const EventEmitter = require("events")
const emitter = new EventEmitter()

// Создаем обработчик, который будет вызван только один раз
emitter.once("initialize", () => {
  console.log("Инициализация выполнена!")
})

// Генерируем событие несколько раз
emitter.emit("initialize") // Инициализация выполнена!
emitter.emit("initialize") // Ничего не происходит
emitter.emit("initialize") // Ничего не происходит
```

### Характеристики once()

1. **Автоматическое удаление**: Обработчик автоматически удаляется после первого срабатывания
2. **Внутренняя реализация**: Использует обертку вокруг обычного обработчика, которая вызывает `removeListener` после первого вызова
3. **Память**: Более эффективен с точки зрения управления памятью для однократных событий

## Практические сценарии использования

### Когда использовать on()

1. **Обработка повторяющихся событий**

   ```javascript
   // Обработка данных из потока
   readStream.on("data", (chunk) => {
     processChunk(chunk)
   })
   ```

2. **Непрерывный мониторинг**

   ```javascript
   // Мониторинг сетевых соединений
   server.on("connection", (socket) => {
     console.log("Новое соединение:", socket.remoteAddress)
   })
   ```

3. **Обработка пользовательских действий**
   ```javascript
   button.on("click", () => {
     updateCounter()
   })
   ```

### Когда использовать once()

1. **Инициализация**

   ```javascript
   // Операция инициализации, которая должна произойти один раз
   app.once("init", () => {
     console.log("Приложение инициализировано")
     loadInitialData()
   })
   ```

2. **Обработка одноразовых событий**

   ```javascript
   // Обработка события подключения к БД
   db.once("connect", () => {
     console.log("Соединение с БД установлено")
   })
   ```

3. **Предотвращение утечек памяти**
   ```javascript
   // Одноразовая обработка ошибки
   process.once("uncaughtException", (err) => {
     console.error("Необработанная ошибка:", err)
     process.exit(1)
   })
   ```

## Комбинирование методов

В некоторых случаях полезно комбинировать оба метода:

```javascript
const EventEmitter = require("events")
const downloader = new EventEmitter()

// Однократная обработка начала загрузки
downloader.once("start", () => {
  console.log("Загрузка начата")
  setupProgressBar()
})

// Многократная обработка прогресса
downloader.on("progress", (percent) => {
  updateProgressBar(percent)
})

// Однократная обработка завершения
downloader.once("complete", () => {
  console.log("Загрузка завершена")
  hideProgressBar()
})
```

## Внутренняя реализация и производительность

Метод `once()` внутренне реализован как обертка вокруг `on()`, которая удаляет обработчик после его первого вызова:

```javascript
// Упрощенная реализация once
function once(eventName, listener) {
  const wrapper = (...args) => {
    this.removeListener(eventName, wrapper)
    return listener.apply(this, args)
  }

  wrapper.listener = listener
  this.on(eventName, wrapper)
  return this
}
```

Это означает:

1. `once()` немного медленнее, чем `on()` из-за дополнительной обертки
2. При использовании `once()` происходит дополнительное удаление обработчика
3. В приложениях с высокой нагрузкой это может иметь небольшое влияние на производительность

## Заключение

Выбор между `on()` и `once()` зависит от конкретного сценария использования:

- Используйте `on()` для событий, которые могут происходить многократно и требуют обработки каждый раз
- Используйте `once()` для событий, которые должны обрабатываться только один раз, например, инициализация или завершение

Правильное использование этих методов помогает создавать более эффективные и предсказуемые асинхронные приложения в Node.js.

---

[[003 JSCore|Назад]]
