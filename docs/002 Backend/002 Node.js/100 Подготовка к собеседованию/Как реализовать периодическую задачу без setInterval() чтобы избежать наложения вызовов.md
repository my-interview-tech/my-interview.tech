---
title: Как реализовать периодическую задачу без setInterval() чтобы избежать наложения вызовов?
draft: true
tags:
  - NodeJS
  - setInterval
  - setTimeout
  - async
  - await
info:
---
`setInterval(fn, delay)` выполняет `fn` **каждые `delay` миллисекунд**, но если `fn` выполняется дольше, чем `delay`, вызовы начнут **накладываться (overlapping)** друг на друга. Это может привести к утечкам памяти, высокой нагрузке на CPU и неожиданным багам.

**Почему возникает накладка?**

```js
setInterval(async () => {   
	console.log('Начало', Date.now());   
	
	// Симуляция долгой задачи (1.5 сек)
	await new Promise((res) => setTimeout(res, 1500));    
	
	console.log('Конец', Date.now()); 
}, 1000);
```

**Ожидание**: вызовы **каждые 1000 мс**.  
**Реальность**: новый вызов запускается **до завершения предыдущего**, создавая параллельные вызовы.

Чтобы реализовать **периодическую задачу без `setInterval()`** и избежать наложения вызовов (race condition), можно использовать **рекурсивный `setTimeout()`**.

**Правильный способ (рекурсивный `setTimeout()`)**

Этот метод **ждёт завершения предыдущего вызова**, прежде чем запустить новый.

```javascript
function task() {   
	console.log("Task executed at", new Date().toISOString());    
	setTimeout(task, 1000); // Запускаем следующий вызов после завершения текущего 
}  

task(); // Запуск задачи`
```

**Преимущество**:
- Новый вызов происходит **только после завершения предыдущего**, поэтому нет наложений.

---

**Альтернативный вариант: `async/await` с `setTimeout()`

Подходит для асинхронных задач, например, запросов в БД или HTTP-запросов.


```js
async function periodicTask() {   
	while (true) {     
		console.log("Running task at", new Date().toISOString());     
		
		// Ждём перед повторным вызовом
		await new Promise((resolve) => setTimeout(resolve, 1000));    
	} 
}  

periodicTask();`
```

**Преимущество**:
- Легко интегрируется с `async` функциями.
- Избегает блокировки Event Loop.

---

**Вывод**
- Используйте **рекурсивный `setTimeout()`** вместо `setInterval()`, чтобы избежать наложения вызовов.
- Для **асинхронных задач** удобнее `async/await` + `setTimeout()`.