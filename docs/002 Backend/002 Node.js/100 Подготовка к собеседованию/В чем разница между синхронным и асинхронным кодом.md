---
title: В чем разница между синхронным и асинхронным кодом
draft: false
tags:
  - "#NodeJS"
  - "#JavaScript"
  - "#асинхронность"
  - "#EventLoop"
  - "#производительность"
  - "#синхронность"
info:
  - "[MDN: Асинхронное программирование](https://developer.mozilla.org/ru/docs/Learn/JavaScript/Asynchronous)"
  - "[Node.js: Асинхронная модель выполнения](https://nodejs.org/ru/docs/guides/blocking-vs-non-blocking/)"
  - "[JavaScript.info: Промисы, async/await](https://javascript.info/async)"
---

# Разница между синхронным и асинхронным кодом

Синхронный и асинхронный код представляют два разных подхода к выполнению операций в программировании. Их различия особенно важны в контексте Node.js, где правильный выбор между ними может существенно влиять на производительность приложения.

## Синхронный код

**Синхронный код** выполняется последовательно, строка за строкой, блокируя выполнение следующих операций до завершения текущей.

### Основные характеристики синхронного кода:

- **Блокирующее выполнение**: каждая операция должна завершиться перед началом следующей
- **Последовательное выполнение**: операции выполняются в точном порядке написания кода
- **Простота понимания**: логика кода прямолинейна и легко отслеживается
- **Возможные проблемы с производительностью**: при длительных операциях вся программа "замирает"

### Пример синхронного кода в Node.js:

```javascript
const fs = require("fs")

console.log("Начало программы")

// Синхронное чтение файла блокирует выполнение
const data = fs.readFileSync("config.json", "utf8")
console.log("Файл прочитан:", data)

console.log("Конец программы")

// Вывод будет в точном порядке:
// 1. "Начало программы"
// 2. "Файл прочитан: [содержимое файла]"
// 3. "Конец программы"
```

## Асинхронный код

**Асинхронный код** позволяет запускать операции без блокирования основного потока выполнения, с обработкой результатов по мере их получения.

### Основные характеристики асинхронного кода:

- **Неблокирующее выполнение**: операции могут выполняться параллельно, не блокируя основной поток
- **Колбэки, промисы или async/await**: используются для обработки результатов асинхронных операций
- **Повышенная производительность**: при ожидании ввода-вывода (I/O) программа может выполнять другие задачи
- **Сложнее отслеживать поток выполнения**: порядок выполнения может не соответствовать порядку написания кода

### Пример асинхронного кода в Node.js:

```javascript
const fs = require("fs")

console.log("Начало программы")

// Асинхронное чтение файла не блокирует основной поток
fs.readFile("config.json", "utf8", (err, data) => {
  if (err) {
    console.error("Ошибка при чтении файла:", err)
    return
  }
  console.log("Файл прочитан асинхронно:", data)
})

console.log("Конец программы")

// Вывод будет в следующем порядке:
// 1. "Начало программы"
// 2. "Конец программы"
// 3. "Файл прочитан асинхронно: [содержимое файла]"
```

## Асинхронный код с использованием промисов:

```javascript
const fs = require("fs").promises

console.log("Начало программы")

fs.readFile("config.json", "utf8")
  .then((data) => {
    console.log("Файл прочитан с промисом:", data)
  })
  .catch((err) => {
    console.error("Ошибка при чтении файла:", err)
  })

console.log("Конец программы")
```

## Асинхронный код с использованием async/await:

```javascript
const fs = require("fs").promises

async function readConfig() {
  console.log("Начало программы")

  try {
    const data = await fs.readFile("config.json", "utf8")
    console.log("Файл прочитан с async/await:", data)
  } catch (err) {
    console.error("Ошибка при чтении файла:", err)
  }

  console.log("Конец функции")
}

readConfig()
console.log("Этот код выполнится до завершения readConfig()")
```

## Основные различия

| **Характеристика**          | **Синхронный код**              | **Асинхронный код**                                 |
| --------------------------- | ------------------------------- | --------------------------------------------------- |
| **Поток выполнения**        | Блокирующий                     | Неблокирующий                                       |
| **Порядок выполнения**      | Гарантированно последовательный | Может варьироваться                                 |
| **Обработка ошибок**        | try/catch блоки                 | Колбэки, catch() или try/catch с async/await        |
| **Использование в Node.js** | Для простых, быстрых операций   | Рекомендуется для I/O операций и длительных задач   |
| **Производительность**      | Ниже при I/O операциях          | Выше при I/O операциях                              |
| **Сложность кода**          | Проще писать и отлаживать       | Может быть сложнее из-за колбэков, цепочек промисов |

## Когда использовать синхронный код

- При простых операциях с минимальной задержкой
- В скриптах инициализации, когда блокировка не критична
- В утилитах командной строки, где простота важнее производительности
- При необходимости строгой последовательности выполнения

## Когда использовать асинхронный код

- При работе с файловой системой (чтение/запись файлов)
- При сетевых запросах (HTTP-запросы, доступ к базам данных)
- В обработчиках событий (особенно в веб-серверах)
- При работе с большими объемами данных
- Для поддержания отзывчивости интерфейса в приложениях

## Заключение

Выбор между синхронным и асинхронным кодом в Node.js зависит от конкретной задачи:

- **Синхронный код** легче писать и понимать, но может блокировать выполнение программы при длительных операциях.
- **Асинхронный код** обеспечивает лучшую производительность для I/O-интенсивных операций, позволяя программе выполнять другие задачи во время ожидания.

В Node.js рекомендуется использовать асинхронный подход в большинстве случаев, особенно при работе с I/O операциями, чтобы максимально использовать преимущества однопоточной событийно-ориентированной архитектуры.

---

[[002 Node.js|Назад]]
