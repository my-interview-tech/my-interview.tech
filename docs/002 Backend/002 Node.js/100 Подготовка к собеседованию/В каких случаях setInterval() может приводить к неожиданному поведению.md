---
title: В каких случаях setInterval() может приводить к неожиданному поведению?
draft: false
tags:
  - "#NodeJS"
  - "#setInterval"
  - "#setTimeout"
  - "#EventLoop"
info:
---

Функция **`setInterval(fn, delay)`** выполняет `fn` каждые `delay` миллисекунд. Однако в реальности возможны **проблемы**, из-за которых вызовы `fn` могут **не соответствовать указанному интервалу**.

**1. Блокировка основного потока (Event Loop)**

Если обработчик (`fn`) выполняется дольше, чем `delay`, вызовы `setInterval()` начнут **задерживаться**.

```javascript
setInterval(() => {
  console.log("Тик", Date.now()) // Блокируем поток (например, тяжелый расчет)

  const start = Date.now()

  while (Date.now() - start < 2000) {} // Блокируем на 2 сек
}, 1000)
```

**Ожидание**: вызовы каждые **1000 мс**.  
**Реальность**: вызовы происходят **с интервалом в 2+ секунды**, так как поток блокируется.

**Как исправить?** Использовать `setTimeout()` вместо `setInterval()`, чтобы учитывать длительность выполнения.

```javascript
function repeatTask() {
  console.log("Тик", Date.now())

  setTimeout(repeatTask, 1000)
}

repeatTask()
```

Теперь каждая итерация **начинается через 1000 мс после завершения предыдущей**.

---

**2. Накопление вызовов (drift)**

Если обработчик `fn` иногда работает дольше, чем `delay`, вызовы могут **накладываться друг на друга**.

```javascript
setInterval(async () => {
  console.log("Начало", Date.now())

  await new Promise((res) => setTimeout(res, 1500)) // Ждем 1.5 сек

  console.log("Конец", Date.now())
}, 1000)
```

**Ожидание**: каждые **1000 мс**.  
**Реальность**: `setInterval()` продолжает запускаться **даже если предыдущий вызов не завершился** → функции начинают **накладываться**.

**Как исправить?** Вызывать следующий `setTimeout()` только после завершения асинхронной операции.

```javascript
async function repeatTask() {
  console.log("Начало", Date.now())

  await new Promise((res) => setTimeout(res, 1500)) // Ждем 1.5 сек

  console.log("Конец", Date.now())

  setTimeout(repeatTask, 1000) // Ждем 1 сек перед следующим запуском
}

repeatTask()
```

Теперь новый вызов начнется **только после завершения предыдущего**.

---

**3. `setInterval()` не гарантирует точность**

Из-за особенностей **event loop**, `setInterval(1000)` **не гарантирует** выполнение ровно через 1000 мс.

```javascript
let prev = Date.now()

setInterval(() => {
  let now = Date.now()

  console.log(`Разница: ${now - prev} мс`)
  prev = now
}, 1000)
```

**Реальность**: Разница между вызовами **не будет ровно 1000 мс**, а может колебаться (~1002-1015 мс).

**Как исправить?** Использовать `setTimeout()` с вычислением точного времени.

```javascript
function preciseInterval() {
  const now = Date.now()
  console.log(`Точное время: ${now}`)

  const nextTick = now + 1000
  setTimeout(preciseInterval, nextTick - Date.now())
}

preciseInterval()
```

Теперь выполнение будет **подстраиваться под точное время**.

---

**4. `setInterval()` продолжает работать, даже если код падает**

Если внутри обработчика произошла ошибка, `setInterval()` **не остановится**, и код будет продолжать выполняться.

```javascript
setInterval(() => {
  console.log("Тик")

  throw new Error("Что-то пошло не так")
}, 1000)
```

**Результат**: Ошибки появляются в консоли, но `setInterval()` продолжает выполняться!

**Как исправить?** Обернуть код в `try...catch`.

```javascript
setInterval(() => {
  try {
    console.log("Тик")
    throw new Error("Ошибка!")
  } catch (err) {
    console.error("Ошибка обработана:", err.message)
  }
}, 1000)
```

Теперь ошибки **не ломают весь процесс**.

**Вывод**

| Проблема                            | Причина                                 | Решение                                            |
| ----------------------------------- | --------------------------------------- | -------------------------------------------------- |
| **Блокировка потока**               | Долгий код мешает таймерам              | Использовать `setTimeout()` вместо `setInterval()` |
| **Накопление вызовов**              | Асинхронные задачи не ждут друг друга   | Ждать завершения с `async/await` + `setTimeout()`  |
| **Неточность интервала**            | Event loop не гарантирует точное время  | Вычислять точное время с `Date.now()`              |
| **Продолжение работы после ошибки** | Ошибки не останавливают `setInterval()` | Использовать `try...catch`                         |

**Итог:** `setInterval()` удобен, но может приводить к **непредсказуемому поведению**. В большинстве случаев **лучше использовать `setTimeout()`** для точного контроля вызовов.

---

[[002 Node.js|Назад]]
