---
title: Почему колбэк промиса (.then()) выполняется раньше чем обработчик setTimeout(fn 0)
draft: true
tags:
  - NodeJS
  - then
  - setTimeout
  - EventLoop
  - microtask
  - macrotask
info:
---
Колбэк промиса `.then()` выполняется раньше, чем обработчик `setTimeout(fn, 0)`, из-за механизма **Event Loop** в JavaScript и разницы между **микрозадачами (Microtasks)** и **макрозадачами (Macrotasks)**.

**Разница между `.then()` и `setTimeout(fn, 0)`**

1. **Колбэк промиса (`.then()`) попадает в очередь микрозадач (Microtask Queue)**.
    - Микрозадачи включают:
        - Обработчики `.then()`, `.catch()`, `.finally()`.
        - Очередь `process.nextTick()` в Node.js.
        - Обработчики `MutationObserver` в браузере.
    - После выполнения основного кода (главного стека вызовов) **сначала выполняются все микрозадачи**.
      
2. **`setTimeout(fn, 0)` попадает в очередь макрозадач (Macrotask Queue)**.
    - Макрозадачи включают:
        - `setTimeout`, `setInterval`, `setImmediate` (в Node.js).
        - Обработчики I/O (например, чтение файла, сетевые запросы).
        - Обработчики UI-ивентов (например, `onclick`).
    - Макрозадачи выполняются **только после микрозадач**.


```javascript
console.log("Start");  

setTimeout(() => {   
	console.log("setTimeout"); 
}, 0);  

Promise.resolve().then(() => {   
	console.log("Promise"); 
});  

console.log("End");`
```

**Разбор выполнения:**

3. `"Start"` → выполняется немедленно (основной стек).
4. `setTimeout(fn, 0)` → помещается в очередь макрозадач.
5. `Promise.resolve().then(...)` → помещается в очередь микрозадач.
6. `"End"` → выполняется немедленно (основной стек завершён).
7. **Очередь микрозадач** выполняется первой: `"Promise"`.
8. **Очередь макрозадач** выполняется после: `"setTimeout"`.

**Вывод в консоли:**

javascript

КопироватьРедактировать

`Start End Promise setTimeout`

### Итог:

- Колбэки промисов (`.then()`) выполняются **раньше**, чем `setTimeout(fn, 0)`, потому что микрозадачи выполняются **до** обработки макрозадач.