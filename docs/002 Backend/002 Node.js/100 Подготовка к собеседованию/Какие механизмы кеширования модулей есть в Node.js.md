---
title: Какие механизмы кеширования модулей есть в Node.js
draft: false
tags:
  - "#NodeJS"
  - "#кеширование"
  - "#модули"
  - "#require"
  - "#ES-модули"
  - "#производительность"
info:
  - "[Официальная документация по модулям Node.js](https://nodejs.org/api/modules.html#modules_caching)"
  - "[ES модули в Node.js](https://nodejs.org/api/esm.html)"
  - "[Как работает require() в Node.js](https://nodejs.org/en/learn/modules/modules-in-nodejs-and-ecmascript-modules)"
---

# Механизмы кеширования модулей в Node.js

В Node.js существует несколько механизмов кеширования, которые позволяют улучшить производительность при многократном импорте модулей. Эти механизмы помогают избежать повторной загрузки и выполнения кода при каждом запросе к модулю, что снижает время загрузки приложения и повышает его производительность.

## 1. Кеширование CommonJS модулей с помощью `require.cache`

Когда вы загружаете модуль с помощью функции `require()`, Node.js не загружает его заново при последующих вызовах. Вместо этого он сохраняет его в кеше в объекте `require.cache`. Таким образом, если модуль уже был загружен, Node.js возвращает его из кеша, избегая повторной компиляции и выполнения кода.

### Пример демонстрации кеширования модулей

```javascript
// module.js
console.log("Модуль загружен!")
module.exports = function () {
  return "Привет из модуля!"
}
```

```javascript
// main.js
console.log("Первая загрузка:")
const firstLoad = require("./module") // Выведет "Модуль загружен!"

console.log("Вторая загрузка:")
const secondLoad = require("./module") // Не выведет сообщение, модуль уже в кеше

console.log("Сравнение ссылок на функции:", firstLoad === secondLoad) // true, обе переменные ссылаются на одну и ту же функцию
```

### Как работает кеширование CommonJS модулей

1. При первом вызове `require('./module')`, Node.js:

   - Разрешает абсолютный путь к модулю
   - Проверяет, есть ли модуль в кеше по этому пути
   - Загружает и выполняет код модуля
   - Кеширует экспортируемый объект
   - Возвращает экспортируемый объект

2. При последующих вызовах, Node.js:
   - Проверяет кеш
   - Находит модуль в кеше
   - Немедленно возвращает кешированный экспортируемый объект

### Доступ к кешу модулей

Вы можете получить доступ к кешу модулей через объект `require.cache`:

```javascript
// Вывести все кешированные модули
console.log(Object.keys(require.cache))

// Получить конкретный модуль из кеша
const modulePath = require.resolve("./module")
console.log(require.cache[modulePath])
```

## 2. Управление кешем модулей

### Очистка кеша для одного модуля

В некоторых случаях, особенно при разработке или тестировании, может потребоваться очистить кеш определенного модуля, чтобы загрузить его заново:

```javascript
// Получаем абсолютный путь к модулю
const modulePath = require.resolve("./module")

// Удаляем модуль из кеша
delete require.cache[modulePath]

// Теперь при повторном require модуль будет загружен заново
const reloadedModule = require("./module") // Снова выведет "Модуль загружен!"
```

### Очистка всего кеша модулей

В редких случаях может понадобиться полная очистка кеша:

```javascript
function clearRequireCache() {
  Object.keys(require.cache).forEach(function (key) {
    delete require.cache[key]
  })
  console.log("Кеш модулей очищен")
}

// Использование
clearRequireCache()
```

> ⚠️ **Внимание**: Полная очистка кеша может привести к нежелательным побочным эффектам, так как это затрагивает и встроенные модули Node.js. Обычно рекомендуется очищать кеш только для конкретных модулей.

## 3. Кеширование модулей в ES модулях (ESM)

ES модули, поддерживаемые в Node.js начиная с версии 12, также используют кеширование, но механизм кеширования отличается от CommonJS:

1. **Единая идентичность модуля** — ESM гарантирует, что для каждого URL модуля существует только один экземпляр модуля.
2. **Неизменяемость экспорта** — в отличие от CommonJS, экспорты ES модулей не могут быть изменены после загрузки.
3. **Статический анализ** — импорты и экспорты анализируются статически перед выполнением кода.

### Пример ES модулей с кешированием

```javascript
// module.mjs
console.log("ES модуль загружен!")
export const value = Math.random()
```

```javascript
// main.mjs
import { value as value1 } from "./module.mjs" // Выведет "ES модуль загружен!"
console.log("Первый импорт:", value1)

import { value as value2 } from "./module.mjs" // Не выполнит модуль снова
console.log("Второй импорт:", value2)

console.log("Значения совпадают:", value1 === value2) // true
```

### Различия в кешировании между CommonJS и ES модулями

| Аспект              | CommonJS (`require()`)                      | ES Модули (`import`)         |
| ------------------- | ------------------------------------------- | ---------------------------- |
| Доступ к кешу       | Через `require.cache`                       | Нет прямого доступа          |
| Очистка кеша        | Возможна через `delete require.cache[path]` | Не предусмотрена в стандарте |
| Изменение экспортов | Возможно динамически                        | Неизменяемые экспорты        |
| Механизм загрузки   | Синхронный                                  | Асинхронный                  |
| Время резолвинга    | Во время выполнения                         | Во время парсинга            |

## 4. Преимущества и недостатки кеширования модулей

### Преимущества

1. **Повышение производительности** — модули загружаются только один раз
2. **Сохранение состояния** — позволяет модулям поддерживать состояние между вызовами
3. **Единая идентичность** — гарантирует, что экземпляр модуля один и тот же во всем приложении

### Недостатки

1. **Потенциальные проблемы при горячей перезагрузке** — изменения в модулях не отражаются автоматически
2. **Увеличение потребления памяти** — все модули остаются в памяти
3. **Сложности при тестировании** — модули с побочными эффектами могут влиять на последующие тесты

## 5. Практические рекомендации по работе с кешированием модулей

1. **Для разработки:**

   ```javascript
   // Настройка автоматической перезагрузки модулей при изменении файлов
   const chokidar = require("chokidar")

   chokidar.watch("./modules").on("change", (path) => {
     const resolvedPath = require.resolve(path)
     delete require.cache[resolvedPath]
     console.log(`Модуль ${path} перезагружен`)
   })
   ```

2. **Для изоляции в тестах:**

   ```javascript
   // Вспомогательная функция для изолированного импорта в тестах
   async function isolatedImport(modulePath) {
     const resolvedPath = require.resolve(modulePath)
     delete require.cache[resolvedPath]
     return require(modulePath)
   }

   // Использование
   it("test specific behavior", async () => {
     const freshModule = await isolatedImport("./module-under-test")
     // Тест с чистым модулем
   })
   ```

3. **Для управления состоянием модулей:**

   ```javascript
   // Фабрика модулей для контролируемого доступа к состоянию
   function createCounter() {
     let count = 0
     return {
       increment: () => ++count,
       getCount: () => count,
       reset: () => {
         count = 0
       },
     }
   }

   module.exports = createCounter()
   ```

## Заключение

Кеширование модулей в Node.js — важный механизм, обеспечивающий производительность и последовательное поведение приложений. Понимание того, как работает кеширование в различных системах модулей (CommonJS и ESM), помогает разрабатывать более эффективные и предсказуемые приложения.

Для большинства приложений механизмы кеширования, встроенные в Node.js, работают прозрачно и не требуют вмешательства. Однако, знание возможностей управления кешем может быть полезным при отладке, разработке и тестировании, особенно в сложных приложениях с большим количеством зависимостей.

---

[[002 Node.js|Назад]]
