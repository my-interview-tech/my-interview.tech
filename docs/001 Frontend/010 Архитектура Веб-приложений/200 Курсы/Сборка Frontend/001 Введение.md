Вводная лекция

## Введение: Что такое FrontOps?

FrontOps (Frontend Operations) — это дисциплина, которая фокусируется на автоматизации, оптимизации и стандартизации процессов фронтенд-разработки. Она включает в себя настройку сборки, управление зависимостями, оптимизацию производительности, автоматизацию тестирования и деплоя клиентского кода.

В отличие от традиционного DevOps, который сосредоточен на серверной инфраструктуре, FrontOps решает уникальные задачи фронтенда: работу с браузерами, оптимизацию загрузки ресурсов, совместимость с различными устройствами и управление сложными зависимостями JavaScript-экосистемы.

Современные фреймворки, такие как Next.js, под капотом используют сложные системы сборки. Next.js традиционно использовал Webpack, но постепенно переходит на Turbopack — новый сборщик, написанный на Rust, который обещает значительное ускорение процесса разработки.

## Истоки: От XMLHttpRequest к jQuery

### Эра XMLHttpRequest

В начале 2000-х годов веб-разработчикам приходилось работать с XMLHttpRequest напрямую для выполнения асинхронных запросов:

```
var xhr = new XMLHttpRequest();
xhr.open('GET', '/api/data', true);
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4 && xhr.status === 200) {
        var data = JSON.parse(xhr.responseText);
        // Обработка данных
    }
};
xhr.send();
```

Это было громоздко, подвержено ошибкам и требовало много boilerplate-кода для обработки различных состояний и ошибок.

### Революция jQuery

jQuery популяризировал Ajax-запросы, предоставив простой и элегантный API:

```
$.ajax({
    url: '/api/data',
    type: 'GET',
    success: function(data) {
        // Обработка данных
    },
    error: function(xhr, status, error) {
        // Обработка ошибок
    }
});
```

jQuery не только упростил Ajax-запросы, но и решил проблемы совместимости между браузерами, что было критически важно в эпоху "браузерных войн".

## Примитивные сборки: Bash и Make

### Начальный этап автоматизации

Простейшие сборки писались на bash или с использованием Make. Основная задача заключалась в склеивании файлов для ускорения загрузки:

```
#!/bin/bash
# Простой скрипт сборки

# Объединение CSS файлов
cat src/css/reset.css src/css/main.css src/css/responsive.css > dist/app.css

# Объединение JavaScript файлов
cat src/js/utils.js src/js/main.js src/js/app.js > dist/app.js

# Минификация (если доступна)
if command -v uglifyjs &> /dev/null; then
    uglifyjs dist/app.js -o dist/app.min.js
fi

echo "Сборка завершена!"
```

Makefile пример:

```
# Makefile для простой сборки
CSS_FILES = src/css/reset.css src/css/main.css src/css/responsive.css
JS_FILES = src/js/utils.js src/js/main.js src/js/app.js

dist/app.css: $(CSS_FILES)
	cat $(CSS_FILES) > dist/app.css

dist/app.js: $(JS_FILES)
	cat $(JS_FILES) > dist/app.js

build: dist/app.css dist/app.js
	@echo "Сборка завершена!"

clean:
	rm -f dist/*

.PHONY: build clean
```

Эти подходы работали для простых проектов, но быстро становились неуправляемыми при росте сложности приложений.

## Эволюция концепции модулей

### IIFE (Immediately Invoked Function Expression)

Паттерн IIFE решал проблему загрязнения глобального пространства имен:

javascript

```
// Модуль калькулятора
var Calculator = (function() {
    // Приватные переменные
    var history = [];
    
    // Приватные функции
    function log(operation, result) {
        history.push(operation + ' = ' + result);
    }
    
    // Публичный API
    return {
        add: function(a, b) {
            var result = a + b;
            log(a + ' + ' + b, result);
            return result;
        },
        
        subtract: function(a, b) {
            var result = a - b;
            log(a + ' - ' + b, result);
            return result;
        },
        
        getHistory: function() {
            return history.slice(); // Возвращаем копию
        }
    };
})();

// Использование
Calculator.add(5, 3); // 8
Calculator.getHistory(); // ["5 + 3 = 8"]
```

### AMD и RequireJS

Asynchronous Module Definition (AMD) позволял асинхронную загрузку модулей:

```
// math.js - определение модуля
define('math', [], function() {
    return {
        add: function(a, b) {
            return a + b;
        },
        multiply: function(a, b) {
            return a * b;
        }
    };
});

// app.js - использование модуля
require(['math'], function(math) {
    console.log(math.add(2, 3)); // 5
    console.log(math.multiply(4, 5)); // 20
});
```

RequireJS конфигурация:

```
requirejs.config({
    baseUrl: 'js/lib',
    paths: {
        'jquery': 'jquery-3.6.0.min',
        'lodash': 'lodash.min',
        'backbone': 'backbone-min'
    },
    shim: {
        'backbone': {
            deps: ['lodash', 'jquery'],
            exports: 'Backbone'
        }
    }
});
```

### CommonJS в Node.js

Node.js принес серверную модульность в JavaScript:

```
// utils.js
const path = require('path');
const fs = require('fs');

function readConfig(configPath) {
    const fullPath = path.resolve(configPath);
    const content = fs.readFileSync(fullPath, 'utf8');
    return JSON.parse(content);
}

function formatDate(date) {
    return date.toISOString().split('T')[0];
}

module.exports = {
    readConfig,
    formatDate
};

// app.js
const { readConfig, formatDate } = require('./utils');
const express = require('express');

const config = readConfig('./config.json');
console.log('Сегодня:', formatDate(new Date()));

const app = express();
app.listen(config.port);
```

## Пакетные менеджеры: NPM и Bower

### NPM Revolution

NPM (Node Package Manager) кардинально изменил способ управления зависимостями:

```
{
  "name": "my-awesome-app",
  "version": "1.0.0",
  "description": "Описание моего приложения",
  "main": "index.js",
  "scripts": {
    "start": "node index.js",
    "dev": "nodemon index.js",
    "build": "webpack --mode production",
    "test": "jest",
    "lint": "eslint src/"
  },
  "dependencies": {
    "express": "^4.18.2",
    "lodash": "^4.17.21",
    "moment": "^2.29.4"
  },
  "devDependencies": {
    "webpack": "^5.75.0",
    "jest": "^29.3.1",
    "eslint": "^8.30.0",
    "nodemon": "^2.0.20"
  },
  "peerDependencies": {
    "react": ">=16.0.0"
  }
}
```

NPM Scripts позволяли автоматизировать рутинные задачи:

```
{
  "scripts": {
    "prebuild": "npm run clean",
    "build": "webpack --mode production",
    "postbuild": "npm run analyze",
    "clean": "rimraf dist/",
    "analyze": "webpack-bundle-analyzer dist/bundle.js",
    "dev": "concurrently \"npm run watch:css\" \"npm run watch:js\"",
    "watch:css": "sass --watch src/scss:dist/css",
    "watch:js": "webpack --mode development --watch"
  }
}
```

### Bower: Фронтенд-специфичный менеджер

Bower был создан специально для фронтенд-зависимостей:

```
{
  "name": "my-frontend-app",
  "dependencies": {
    "jquery": "~3.6.0",
    "bootstrap": "~5.2.0",
    "fontawesome": "~6.2.0"
  },
  "resolutions": {
    "jquery": "3.6.0"
  }
}
```

Bower устанавливал пакеты в плоскую структуру, что решало проблемы с дублированием зависимостей, но в итоге NPM evolved и поглотил эту функциональность.

## Таск-менеджеры: Grunt и Gulp

### Grunt: Конфигурационный подход

```Gruntfile.js
// Gruntfile.js
module.exports = function(grunt) {
    grunt.initConfig({
        // Очистка директории
        clean: {
            dist: ['dist/']
        },
        
        // Компиляция SASS
        sass: {
            dist: {
                files: {
                    'dist/css/main.css': 'src/scss/main.scss'
                }
            }
        },
        
        // Минификация CSS
        cssmin: {
            target: {
                files: {
                    'dist/css/main.min.css': 'dist/css/main.css'
                }
            }
        },
        
        // Объединение JavaScript
        concat: {
            dist: {
                src: [
                    'src/js/utils.js',
                    'src/js/components/*.js',
                    'src/js/main.js'
                ],
                dest: 'dist/js/app.js'
            }
        },
        
        // Минификация JavaScript
        uglify: {
            dist: {
                files: {
                    'dist/js/app.min.js': 'dist/js/app.js'
                }
            }
        },
        
        // Отслеживание изменений
        watch: {
            scss: {
                files: ['src/scss/**/*.scss'],
                tasks: ['sass', 'cssmin']
            },
            js: {
                files: ['src/js/**/*.js'],
                tasks: ['concat', 'uglify']
            }
        }
    });
    
    // Загрузка плагинов
    grunt.loadNpmTasks('grunt-contrib-clean');
    grunt.loadNpmTasks('grunt-contrib-sass');
    grunt.loadNpmTasks('grunt-contrib-cssmin');
    grunt.loadNpmTasks('grunt-contrib-concat');
    grunt.loadNpmTasks('grunt-contrib-uglify');
    grunt.loadNpmTasks('grunt-contrib-watch');
    
    // Определение задач
    grunt.registerTask('build', ['clean', 'sass', 'cssmin', 'concat', 'uglify']);
    grunt.registerTask('dev', ['build', 'watch']);
    grunt.registerTask('default', ['build']);
};
```

### Gulp: Потоковый подход

```
// gulpfile.js
const gulp = require('gulp');
const sass = require('gulp-sass')(require('sass'));
const concat = require('gulp-concat');
const uglify = require('gulp-uglify');
const cleanCSS = require('gulp-clean-css');
const sourcemaps = require('gulp-sourcemaps');
const browserSync = require('browser-sync').create();
const imagemin = require('gulp-imagemin');
const autoprefixer = require('gulp-autoprefixer');

// Пути к файлам
const paths = {
    styles: {
        src: 'src/scss/**/*.scss',
        dest: 'dist/css/'
    },
    scripts: {
        src: 'src/js/**/*.js',
        dest: 'dist/js/'
    },
    images: {
        src: 'src/images/**/*',
        dest: 'dist/images/'
    }
};

// Обработка стилей
function styles() {
    return gulp.src(paths.styles.src)
        .pipe(sourcemaps.init())
        .pipe(sass().on('error', sass.logError))
        .pipe(autoprefixer({
            cascade: false
        }))
        .pipe(cleanCSS())
        .pipe(sourcemaps.write('./'))
        .pipe(gulp.dest(paths.styles.dest))
        .pipe(browserSync.stream());
}

// Обработка скриптов
function scripts() {
    return gulp.src(paths.scripts.src)
        .pipe(sourcemaps.init())
        .pipe(concat('app.js'))
        .pipe(uglify())
        .pipe(sourcemaps.write('./'))
        .pipe(gulp.dest(paths.scripts.dest));
}

// Оптимизация изображений
function images() {
    return gulp.src(paths.images.src)
        .pipe(imagemin([
            imagemin.gifsicle({interlaced: true}),
            imagemin.mozjpeg({quality: 75, progressive: true}),
            imagemin.optipng({optimizationLevel: 5}),
            imagemin.svgo({
                plugins: [
                    {removeViewBox: true},
                    {cleanupIDs: false}
                ]
            })
        ]))
        .pipe(gulp.dest(paths.images.dest));
}

// Локальный сервер
function serve() {
    browserSync.init({
        server: {
            baseDir: './dist'
        }
    });
    
    gulp.watch(paths.styles.src, styles);
    gulp.watch(paths.scripts.src, scripts).on('change', browserSync.reload);
    gulp.watch('*.html').on('change', browserSync.reload);
}

// Отслеживание изменений
function watch() {
    gulp.watch(paths.styles.src, styles);
    gulp.watch(paths.scripts.src, scripts);
    gulp.watch(paths.images.src, images);
}

// Экспорт задач
exports.styles = styles;
exports.scripts = scripts;
exports.images = images;
exports.watch = watch;
exports.serve = serve;

// Сборка проекта
exports.build = gulp.parallel(styles, scripts, images);

// Разработка
exports.dev = gulp.series(exports.build, serve);

// Задача по умолчанию
exports.default = exports.build;
```

Gulp революционизировал сборку благодаря концепции потоков (streams), что позволяло обрабатывать файлы в памяти без создания промежуточных файлов на диске.

## Эра бандлинга

### Browserify: Модули Node.js в браузере

Browserify позволил использовать CommonJS модули в браузере:

```
// math.js
function add(a, b) {
    return a + b;
}

function multiply(a, b) {
    return a * b;
}

module.exports = { add, multiply };

// app.js
const { add, multiply } = require('./math');
const _ = require('lodash');

console.log(add(2, 3)); // 5
console.log(multiply(4, 5)); // 20
console.log(_.chunk([1, 2, 3, 4, 5, 6], 2)); // [[1, 2], [3, 4], [5, 6]]
```
Команда сборки:

```
browserify app.js -o bundle.js
```

## Современные сборщики

### Webpack: Революция в сборке

Webpack объединил JavaScript и assets в единую систему сборки:

```
// webpack.config.js
const path = require('path');
const HtmlWebpackPlugin = require('html-webpack-plugin');
const MiniCssExtractPlugin = require('mini-css-extract-plugin');
const OptimizeCSSAssetsPlugin = require('optimize-css-assets-webpack-plugin');
const TerserPlugin = require('terser-webpack-plugin');

module.exports = (env, argv) => {
    const isProduction = argv.mode === 'production';
    
    return {
        entry: {
            app: './src/index.js',
            vendor: ['react', 'react-dom', 'lodash']
        },
        
        output: {
            path: path.resolve(__dirname, 'dist'),
            filename: isProduction 
                ? '[name].[contenthash].js' 
                : '[name].js',
            clean: true
        },
        
        module: {
            rules: [
                {
                    test: /\.jsx?$/,
                    exclude: /node_modules/,
                    use: {
                        loader: 'babel-loader',
                        options: {
                            presets: ['@babel/preset-env', '@babel/preset-react'],
                            plugins: ['@babel/plugin-proposal-class-properties']
                        }
                    }
                },
                {
                    test: /\.scss$/,
                    use: [
                        isProduction ? MiniCssExtractPlugin.loader : 'style-loader',
                        'css-loader',
                        'postcss-loader',
                        'sass-loader'
                    ]
                },
                {
                    test: /\.(png|jpe?g|gif|svg)$/,
                    type: 'asset/resource',
                    generator: {
                        filename: 'images/[name].[hash][ext]'
                    }
                },
                {
                    test: /\.(woff|woff2|eot|ttf|otf)$/,
                    type: 'asset/resource',
                    generator: {
                        filename: 'fonts/[name].[hash][ext]'
                    }
                }
            ]
        },
        
        plugins: [
            new HtmlWebpackPlugin({
                template: './src/index.html',
                minify: isProduction
            }),
            
            ...(isProduction ? [
                new MiniCssExtractPlugin({
                    filename: '[name].[contenthash].css'
                })
            ] : [])
        ],
        
        optimization: {
            minimize: isProduction,
            minimizer: [
                new TerserPlugin({
                    terserOptions: {
                        compress: {
                            drop_console: true
                        }
                    }
                }),
                new OptimizeCSSAssetsPlugin()
            ],
            
            splitChunks: {
                chunks: 'all',
                cacheGroups: {
                    vendor: {
                        test: /[\\/]node_modules[\\/]/,
                        name: 'vendors',
                        chunks: 'all'
                    }
                }
            }
        },
        
        devServer: {
            contentBase: './dist',
            hot: true,
            port: 3000,
            historyApiFallback: true
        },
        
        devtool: isProduction ? 'source-map' : 'eval-source-map'
    };
};
```

### Rollup: Оптимизация для библиотек

Rollup конфигурация для библиотеки:

```
// rollup.config.js
import babel from '@rollup/plugin-babel';
import resolve from '@rollup/plugin-node-resolve';
import commonjs from '@rollup/plugin-commonjs';
import terser from '@rollup/plugin-terser';
import pkg from './package.json';

const isProduction = process.env.NODE_ENV === 'production';

export default {
    input: 'src/index.js',
    
    external: ['react', 'react-dom', 'lodash'],
    
    output: [
        {
            file: pkg.main,
            format: 'cjs',
            sourcemap: true
        },
        {
            file: pkg.module,
            format: 'esm',
            sourcemap: true
        },
        {
            file: pkg.browser,
            format: 'umd',
            name: 'MyLibrary',
            sourcemap: true,
            globals: {
                react: 'React',
                'react-dom': 'ReactDOM',
                lodash: '_'
            }
        }
    ],
    
    plugins: [
        resolve({
            browser: true
        }),
        
        commonjs(),
        
        babel({
            babelHelpers: 'bundled',
            exclude: 'node_modules/**',
            presets: ['@babel/preset-env', '@babel/preset-react']
        }),
        
        isProduction && terser()
    ].filter(Boolean)
};
```

### Vite: Лучшее из двух миров

```
// vite.config.js
import { defineConfig } from 'vite';
import react from '@vitejs/plugin-react';
import { resolve } from 'path';

export default defineConfig({
    plugins: [react()],
    
    resolve: {
        alias: {
            '@': resolve(__dirname, 'src'),
            '@components': resolve(__dirname, 'src/components'),
            '@utils': resolve(__dirname, 'src/utils')
        }
    },
    
    css: {
        preprocessorOptions: {
            scss: {
                additionalData: `@import "@/styles/variables.scss";`
            }
        }
    },
    
    build: {
        rollupOptions: {
            output: {
                manualChunks: {
                    vendor: ['react', 'react-dom'],
                    ui: ['@mui/material', '@emotion/react']
                }
            }
        },
        
        sourcemap: true,
        minify: 'esbuild',
        
        // Настройки для библиотек
        lib: {
            entry: resolve(__dirname, 'src/index.js'),
            name: 'MyLib',
            formats: ['es', 'umd']
        }
    },
    
    server: {
        port: 3000,
        hot: true,
        proxy: {
            '/api': {
                target: 'http://localhost:8080',
                changeOrigin: true
            }
        }
    },
    
    optimizeDeps: {
        include: ['lodash', 'axios']
    }
});
```
### Esbuild: Скорость прежде всего

```
// build.js
const esbuild = require('esbuild');

esbuild.build({
    entryPoints: ['src/index.js'],
    bundle: true,
    minify: true,
    sourcemap: true,
    target: ['chrome90', 'firefox88', 'safari14'],
    outfile: 'dist/bundle.js',
    
    // Внешние зависимости
    external: ['react', 'react-dom'],
    
    // Замена переменных окружения
    define: {
        'process.env.NODE_ENV': '"production"'
    },
    
    // Загрузчики для различных типов файлов
    loader: {
        '.png': 'file',
        '.svg': 'text'
    }
}).catch(() => process.exit(1));
```

## Современные технологии и будущее

### ES Modules: Нативная модульность


```
// utils.js
export const API_URL = 'https://api.example.com';

export function fetchData(endpoint) {
    return fetch(`${API_URL}/${endpoint}`)
        .then(response => response.json());
}

export default class Logger {
    constructor(prefix) {
        this.prefix = prefix;
    }
    
    log(message) {
        console.log(`[${this.prefix}] ${message}`);
    }
}

// app.js
import Logger, { fetchData, API_URL } from './utils.js';

const logger = new Logger('APP');
logger.log(`API URL: ${API_URL}`);

fetchData('users')
    .then(users => {
        logger.log(`Loaded ${users.length} users`);
    });
    
```

### Dynamic Imports: Ленивая загрузка

```
// Условная загрузка модуля
async function loadChart() {
    if (shouldShowChart()) {
        const { Chart } = await import('./chart.js');
        return new Chart();
    }
}

// React code splitting
import { lazy, Suspense } from 'react';

const LazyComponent = lazy(() => import('./LazyComponent'));

function App() {
    return (
        <Suspense fallback={<div>Loading...</div>}>
            <LazyComponent />
        </Suspense>
    );
}

// Webpack magic comments
const module = await import(
    /* webpackChunkName: "feature-module" */
    /* webpackPrefetch: true */
    './feature-module.js'
);
```

### ES Modules в браузере

```
<!DOCTYPE html>

<html>

<head>

<title>Native ES Modules</title>

</head>

<body>

<script type="module">

import { render } from './renderer.js';

import config from './config.js';

render(document.body, config);

</script>

<!-- Fallback для старых браузеров -->

<script nomodule src="./bundle.js"></script>

</body>

</html>
```

Import Maps для управления зависимостями:

```
<script type="importmap">
{
    "imports": {
        "lodash": "https://cdn.skypack.dev/lodash@4.17.21",
        "react": "https://cdn.skypack.dev/react@18.2.0",
        "react-dom": "https://cdn.skypack.dev/react-dom@18.2.0"
    }
}
</script>

<script type="module">
    import _ from 'lodash';
    import React from 'react';
    import ReactDOM from 'react-dom';
    
    // Использование модулей
</script>
```

### WebAssembly (WASM): Производительность нового уровня

```
// Загрузка WASM модуля
async function loadWasm() {
    const wasmModule = await WebAssembly.instantiateStreaming(
        fetch('./math.wasm')
    );
    
    return wasmModule.instance.exports;
}

// Использование
loadWasm().then(wasm => {
    const result = wasm.fibonacci(40);
    console.log(`Fibonacci(40) = ${result}`);
});

// Интеграция с bundler (Webpack)
import wasmModule from './math.wasm';

wasmModule().then(wasm => {
    const result = wasm.calculatePi(1000000);
    console.log(`Pi ≈ ${result}`);
});

```

## Заключение

Эволюция FrontOps отражает рост сложности веб-приложений и требований к производительности. От простых скриптов конкатенации файлов мы пришли к сложным системам сборки, способным оптимизировать код, управлять зависимостями и обеспечивать отличный developer experience.

Современные тренды указывают на:

- Ускорение сборки (Esbuild, SWC, Turbopack)

- Нативную поддержку ES Modules

- Интеграцию WebAssembly для критичных к производительности задач

- Развитие edge computing и серверных компонентов

CommonJS постепенно уходит в прошлое, уступая место ES Modules, которые обеспечивают лучшую оптимизацию и tree-shaking. Будущее FrontOps будет определяться балансом между производительностью, простотой использования и гибкостью конфигурации.

Что такое FrontOps?

next // под капотом использует webpack и переключение на turbopack

|     |     |
| --- | --- |
|     |     |
jQuery - популизировал Ajax запросы, когда раньше писали через xmlHttpRequest.

простейшие сборки пишутся на bash , или make.
склеивали файлы для загрузки быстрой.


Концепция модулей
IIFE | AMD/RequireJS

Node.js (Можно писать модульный код)
CommonJS 

```node.js
const path = require('path')
require('jquire')
cons { update } = require('utils')
```

NPM 

Bower (пакетный менеджер)

Grunt & Gulp (таск менеджеры)(что то делаем с определенной периодичностью, баш скрипты писать не удобно, а галп можно использовать для сборки, если меняется манифест то через галп можно внести изменение и ускорит сборку)
покажи пример gulp конфига

Бандлинг (browserfiry) использование npm пакетов (require) в сборке при билде а не в рантайме. эмулирует модули.

Сборка
* Webpack (обьединил js и assets)
* Оптимизация сборки (terser - сжатие кода, есть песочница, транспалинг (src (svs?) и babel), сборка под окружение, оптимизация )
* Rollup / Parcel (создались потому что вебпак медленный, rollup собирает код под библиотеки с оптимизацией и первый tree-shaking на esmodules), rollup - сборка под библиотеку.
* Esbuild (написан на go) , его нельзя конфигурировать, очень быстрый, заточен под библиотеки.
* Vite (esbuild + rollup) 

Дальнейшее развитие технологий
ES Modules
Dynmic imports
ES Modules in browser (не рекомендуется)
Активное развитие спецификации es modules
common js - deprecated технология
WASM


## База вопросов для собеседований по FrontOps

### 1. Основы FrontOps

Концептуальные вопросы:

- Что такое FrontOps и чем он отличается от DevOps?

- Какие задачи решает FrontOps в современной разработке?

- Как эволюционировала фронтенд-разработка от простых HTML страниц до современных SPA?

- Почему возникла необходимость в автоматизации фронтенд-процессов?

### 2. Эволюция Ajax и HTTP-запросов

Исторический контекст:

- Как работал XMLHttpRequest до появления jQuery?

- Какой вклад внес jQuery в популяризацию Ajax-запросов?

- Чем fetch API отличается от XMLHttpRequest?

- Какие современные альтернативы Ajax существуют (GraphQL, Server-Sent Events, WebSockets)?

Практические вопросы:

- Напишите пример XMLHttpRequest без библиотек

- Как бы вы реализовали аналог $.ajax() на чистом JavaScript?
- ### 3. Первые сборки и их эволюция

Базовые концепции:

- Зачем нужно было склеивать файлы в ранних веб-приложениях?

- Какие проблемы решали bash-скрипты и Makefile в сборке?

- Почему простейшие сборки стали недостаточными?

Практические вопросы:

- Напишите bash-скрипт для конкатенации CSS/JS файлов

- Как бы вы оптимизировали загрузку ресурсов без современных бандлеров?

### 4. Система модулей

IIFE (Immediately Invoked Function Expression):

- Что такое IIFE и зачем он использовался?

- Как IIFE решал проблему глобальных переменных?

- Приведите пример модуля на IIFE

- Какие ограничения у IIFE паттерна?

AMD/RequireJS:

- Что означает AMD (Asynchronous Module Definition)?

- Как работает RequireJS?

- В чем преимущества асинхронной загрузки модулей?

- Почему AMD не стал стандартом?

CommonJS:

- Как работает система модулей CommonJS?

- Объясните разницу между require() и module.exports

- Почему CommonJS подходит для серверной среды Node.js?

- Какие проблемы у CommonJS в браузере?

ES Modules:

- Чем ES Modules отличается от CommonJS?

- Что такое tree-shaking и как он работает с ES Modules?

- Объясните static vs dynamic imports

- Можно ли использовать ES Modules в браузере напрямую?

Практические вопросы:

- Перепишите CommonJS модуль в ES Module синтаксис

- Как реализовать условный импорт модуля?

- Объясните разницу между default и named exports

### 5. Пакетные менеджеры

NPM:

- Что такое NPM и как он изменил экосистему JavaScript?

- Объясните структуру package.json

- Чем отличаются dependencies, devDependencies, peerDependencies?

- Как работает семантическое версионирование (semver)?

- Что такое npm scripts и как их использовать?

Bower:

- Почему появился Bower и чем он отличался от NPM?

- Почему Bower стал deprecated?

- Какие проблемы решал Bower в своё время?

Современные альтернативы:

- Сравните NPM, Yarn, PNPM

- Что такое монорепозитории и как ими управлять?

### 6. Таск-менеджеры

Grunt:

- Что такое Grunt и какие задачи он решал?

- Приведите пример Gruntfile.js

- Какие популярные плагины Grunt вы знаете?

Gulp:

- Чем Gulp отличается от Grunt?

- Объясните концепцию streams в Gulp

- Напишите пример Gulp таска для обработки SCSS

- Как Gulp ускоряет сборку по сравнению с Grunt?

Практический пример Gulp конфига:
```
const gulp = require('gulp');
const sass = require('gulp-sass');
const concat = require('gulp-concat');
const uglify = require('gulp-uglify');
const browserSync = require('browser-sync').create();

// Обработка SCSS
gulp.task('styles', () => {
  return gulp.src('src/scss/**/*.scss')
    .pipe(sass().on('error', sass.logError))
    .pipe(gulp.dest('dist/css'))
    .pipe(browserSync.stream());
});

// Обработка JS
gulp.task('scripts', () => {
  return gulp.src('src/js/**/*.js')
    .pipe(concat('app.js'))
    .pipe(uglify())
    .pipe(gulp.dest('dist/js'));
});

// Отслеживание изменений
gulp.task('watch', () => {
  gulp.watch('src/scss/**/*.scss', gulp.series('styles'));
  gulp.watch('src/js/**/*.js', gulp.series('scripts'));
});

gulp.task('default', gulp.parallel('styles', 'scripts', 'watch'));
```

### 7. Бандлинг и сборщики

Browserify:

- Что такое Browserify и какую проблему он решал?

- Как Browserify эмулирует модули Node.js в браузере?

- Чем ограничен Browserify?

Webpack:

- Что такое Webpack и чем он революционен?

- Объясните концепцию entry points, loaders, plugins

- Как Webpack обрабатывает не-JS ресурсы (CSS, изображения)?

- Что такое code splitting и lazy loading в Webpack?

- Как настроить hot module replacement (HMR)?

- Объясните разницу между development и production сборками

Rollup:

- Для чего оптимизирован Rollup?

- Что такое tree-shaking и почему Rollup в этом лучше?

- Когда стоит выбрать Rollup вместо Webpack?

- Как Rollup работает с ES Modules?

Parcel:

- Какие проблемы Webpack решает Parcel?

- Что означает "zero configuration" в Parcel?

- Какие ограничения у Parcel?

Esbuild:

- Почему Esbuild такой быстрый?

- Какие ограничения у Esbuild в плане конфигурации?

- Когда стоит использовать Esbuild?

Vite:

- Как Vite комбинирует Esbuild и Rollup?

- Что такое "no-bundle" development в Vite?

- Чем Vite отличается от Create React App?

- Как Vite использует нативные ES Modules в development?

### 8. Оптимизация сборки

Минификация и сжатие:

- Что такое Terser и как он работает?

- Приведите примеры оптимизаций кода

- Как работает gzip/brotli сжатие?

Транспайлинг:

- Что такое Babel и зачем он нужен?

- Как настроить Babel для поддержки старых браузеров?

- Что такое polyfills и когда их использовать?

Оптимизация под окружение:

- Как настроить разные сборки для dev/prod?

- Что такое environment variables в сборке?

- Как оптимизировать сборку для разных платформ?

### 9. Современные технологии

ES Modules в браузере:

- Можно ли использовать ES Modules без сборки?

- Какие ограничения у нативных ES Modules?

- Что такое import maps?

Dynamic Imports:

- Как работают динамические импорты?

- Приведите пример code splitting с dynamic import

- Как обрабатывать ошибки при динамических импортах?

WebAssembly (WASM):

- Что такое WebAssembly и зачем он нужен?

- Как интегрировать WASM в JavaScript приложение?

- Какие задачи лучше решать через WASM?

### 10. Практические сценарии

Миграция проектов:

- Как мигрировать с Webpack 4 на Webpack 5?

- Как перевести проект с CommonJS на ES Modules?

- Стратегии миграции с устаревших сборщиков

Отладка сборки:

- Как анализировать bundle size?

- Как найти причины медленной сборки?

- Инструменты для профилирования сборки

Performance:

- Как оптимизировать время сборки?

- Что такое bundle splitting и зачем он нужен?

- Как настроить caching в сборке?

Эта структура покрывает все основные аспекты FrontOps от исторического контекста до современных технологий и может служить основой для собеседований разного уровня сложности.