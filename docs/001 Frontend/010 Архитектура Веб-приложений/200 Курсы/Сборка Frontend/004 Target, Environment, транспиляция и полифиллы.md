Environment (где работает JS)
* Browser (chromium, safari, firefox)
* Server (nodejs, deno, bun)
* Desktop (electron, tauri)
* Browser extension
* Microcontrollers (espruino)
* Web/Service-worker

Target (с точки зрения сборки)
По умолчанию установлен Browser.

Где будет работать наш код?
* У окружения есть свои особенности
* Окружение может не поддерживать некоторые возможности языка

Как мы можем адаптировать код в той среде где он будет работать?

* Транспайлинг
	Компиляция - перевод исходного кода в язык более низкого уровня.
	При транспайлинге уровень языка не меняется (в нашем случае JS -> JS).
	AST (Abstract Syntax Tree) AST Explorer
	Поточный парсен (Роман Гранов)
	Статический анализ кода - анализ исходного кода программного обеспечения, производимый без реального выполнения исследуемых программ. Позволяет выявить проблемы в коде без его запуска.
	Где используется AST? 
	* Траспайлинг
	* Трансформеры (ts-morph)
	* Миграции (jscodeshift)
	* Линтеры (eslint)
	* Сборщики (webpack)
	* nodejs (cjs lexer analyzer)
	* tree shaking
	codemod (что это и какой пример?)

Транспайлеры
* babel (плох с точки зрения perfomance)
* swc (аналог babel, написан на Rust)
* tsc (минусы при транспайлинге)
* esbuild

AST CSS

REPL 
* babel
* swc
* typescript
* babel optional chaining plugin (как работает по копотом?)

Как использовать AST?
Можно заюзать плагин acorn (который используется под капотом babel).
vscode ast explorer


* Полифиллы - это код, реализующий какую-то функциональность, которая не поддерживается в данном окружении.
	Promise.try (caniuse)

В чем разница?
Когда ужен полифил, а когда транспайлинг?

Можно ли запустить код без внесения изменений?

Где нужен транспайлинг, а где полифилл?

```js
const a = 5;
```

```js
Promise.try
```

```js
let b = BigInt(100)
```

```js
new IntersectionObserver
```

```js
async function request() {
	const response = await fetch();
}
```

Как написать полифил?

Проверить поддержку полифила у окружения (global.this есть ли метод)
В случае отсутствия добавить недостающий метод
Патчим глобальный объект (либо его прототип)
Promise.try polyfill

```js
if(!Promise.try) {
	Promise.try = function() {}
}
```

```js
if(!String.prototype.toWellFormed) {
	String.prototype.toWellFormed = function() {
	...
	}
}
```

#### Ponyfill

Polyfill - monkey patch
Ponyfill - use instead of native

```js
// Polyfill

Number.isNaN ??= function (value) {
	return value !== value;
}

Number.isNaN(5)

```

```js
// Ponyfill

function isNaNPonyfill(value) {
	return value !== value;
}

isNaNPonyfill(5)
```

У сборщиков есть возможность использования Ponyfill за вас.

Core-js - оттуда можно использовать Polyfill для EcmaScript.

* core-js
* core-js-pure
* core-js-compact

CSS и Web отдельно.
ResizeObserver, IntersectionObserver, clipboard, DOM methods

#### Какие трансформации и полифилы использовать?

Срезаем список:

* Полифилы только для тех методов, которые используются в коде.
* Отказаться от трансформации/ подключения полифилов для актуальных методов? Что значит актуальных? - поддерживаемых в большинстве окружений.

Target

Ecmasript version ES2020, ES2022, version histrory

Чем плох es-version
* Неоднородность появления фичей в окружениях
* Нет связи между es verion и поддержкой в окружениях
* WeakRef caniuse

Классный способ таргетить сборку - Browserlist

Browserlist
Конфигурация описывающующая target сборки.
Используется во многих инструментах сборки.
Конфиг представляет собой список версии окружений.

Автоматизация подключения полифилов
* useBuiltIns mods
* Автоматически подключает только нужные полифилы
* Entry - все полифилы нужные для работы в указанном target
* Usage - полифилы только используемых возможностей EcmaScript
Статический анализ кода

Веб полифилы
* Не подключаются автоматически
* Их нет в core-js (почти)
* Нужно подключать вручную
* eslint-plugin-compat

Performance
* Полифилы и транспайлинг отрицательно влияют на perf
* Трансформированный код всегда медленнее и тяжелее нативного (optional chaining)
* Блокирующая загрузка и инициализация кода
* Чем старше target тем более радикальны изменения кода

Что делать?
Выстраивать бизнес процессы (собирать статистику браузеров, учитывать прибыль и PR)
Проводить эксперименты по оптимальной схеме загрузке полифилов
Искать золотую середину между поддержкой и производительностью

CSS 
* postcss
* postcss AST
* postcss-preset-env
* features list
* :has polyfill

Lightning CSS (Rust)
* Website
* Features
* Stylo

Browser
* Самый сложный таргет для сборки
* Не контролируем окружение
* Варианты моудльной системы:
* Собственный рантайм + jsonp
* System.js
* Require.js (fetch + eval)
* Нативный ESM

NodeJS
* Полностью контролируем окружение
* Путаница с системой модулей из-за CJS legacy
* Варианты модульной системы:
* Собственный рантайм / System.js
* Нативный ESM
* Нативный CJS
* Оба варианта

Desktop
* NodeJS + Chromium
* Полностью контролируем окружение
* То же самое что и в nodejs + фиксированная версия браузера

Extention
* Строгие политики безопасности
* Запрещена загрузка файлов со сторонних ресурсов
* Бандлим все
* Интеграция манифеста в сборку

Web/Service-worker
* Те же ограничения что и у браузера
* Лучше бандлить и использовать понифилы
* Варианты модульной системы как у браузера
* Ограниченный доступ к API браузера

Транспайлеры
* babel (поддерживает preset-env, автоматическое подключение полифилов и browserlist, медленный (purejs), большое количество плагинов.
* SWC (имеет свой preset-env и автоматическое подключение полифилов, поддерживает browserlist, Работает хуже (есть баги в работе usage, быстрее babel и меньше плагинов, писать собственные нужно на rust)).
* tsc (не поддерживаето browserslist, только es-x target, не умеет поставлять полифилы, только транспайлит код в зависимости от target, нельзя писать плагины (сторонние решение - ts-morph/ ts-loader)).