

Основные свойства модулей:
* изолированность | инкапсуляция
* интерфейсность
* переиспользуемость
* зависимости

iife решал проблему с областью видимости, перебивал var. 

при переезде с es5 на es6 спрашивали на собесе напи сать iife 

пример замыкания - iife

amd -  async module definition
why amd - статья - реализация спецификации require.js

commonJS cjs

главное свойство, супер динамическая работа commonjs, обьявляем модули через require

exports использовать и шатать его везде.

свойства cjs
* синхронная загрузка
* изоляция пространства имен
* единичный экспорт (module.exports)
* позднее связывание (lazy linking)
* локальные зависимости
* ориентированность на файлы
* кеширование модулей (подключи несколько раз один и тот же модуль и мы увидим что вызов модуля произойдет 1 раз (пример))

можно использовать console.log(require.cache), модуль можно удалить из кеша через delete

как написан commonjs ? на ноде подкопотно

```js
(function(exports, require, module, __filename, __dirname) {
	function add(a, b {
		return a + b
	}

	module.exports = { add }
})
```

nodeJS - CJS
Browser - AMS

UMD Patter

в реакте16 был такой код.


свойства umd

* универсальное решение для работы модулей во всех окружениях
* модуль будет работать как в commonjs так и в amd
* overhead на код инициализации

EcmaScript Modules

ESM стал частью спецификации языка.

Ключевые слова export/import
export default - будет заэкспортирована 1 сущность, какие могут быть пробелмы?

Свойства ESM
* синхронная и асинхронная загрузка (ради этого и делали)
* изоляция пространства имен
* единичный экспорт
* универсальность (browser/nodejs)
* кеширование модулей

Преимущества
* спецификация - часть языка
* поддержка всеми платформами
* возможность динамического подключения модулей
* tree shaking (возможность статического анализа)

Tree shaking - технология которая позволяет компилятору понимать какие куски кода будут вызваны а какие нет, неиспользуемые удаляются.
Подобная технология была и в rollup

подобная штуку делает terser.
но можно из webpack из под копота сделать (как?)

console.log - это sideEffect, будет ли он в сборке? как это может выстрелить? отработает ли на нем treeShaking?

пакет в пакете реализован в lodash

работает ли tree shaking в динамических импортах?

CJS & ESM
* Поддерживаются нативно
* Проблема - совместимость модульных систем
interoperability

Interop
одна модульная система в фале
но можно использовать import() в cjs
или require(createRequire) в ESM
ESM import CJS

1. ESM -> ESM
   ESM import CJS interop dox
   CJS module lexer
   CreateRequire
   
ESM -> Parse Module -> Convert export CJS to ESM -> CJS
   
2. CJS -> CJS

Experimental support in nodejs
только синхронные модули (без top level await)
`__esModule`: true

ESM .mjs extension, type: module, --input-type=module, syntax detection

CJS -.cjs extension, type: commonjs, --input-type-commonjs, syntax detection

PureESM - не поставляется в commonjs (раскрой тему)

```js
import { feature } from './lib' with { lazyInit: true }
```

3. ESM -> CJS


4. CJS -> ESM

## Нативные модули в браузере

CJS запускается в браузере только через бандлинг.

ESM нативно поддерживаются в браузерах

```html
<script type='module' src='index.js'/>
```

SystemJS - это альтернативный загрузчик модулей для браузеров.

используется в mf полифил для старых браузеров.

Module Loader
Repo

| tool           | uncached | cached |
| -------------- | -------- | ------ |
| Native Modules | 1668ms   | 49ms   |
| SystemJS       | 2334ms   | 81ms   |

## Сборщики и модули

Webpack - свой рантайм.
Vite, Rollup, Esbuild - ESM only.

## Итоги

Рассмотрели:
* Программные реализации модулей в JS
* Нативные реализации модулей
* Interoperability
* Поддержка модулей в nodejs в браузере

JSONP в контексте сборки.