# Основные термины сборки Frontend

## 1. Входная точка (Entrypoint)

**Entrypoint** — файл(ы), с которых начинается выполнение приложения. 

Например, `index.js` в Webpack или `main.ts` в Vite. В проекте может быть несколько entrypoint-ов, но обычно указывается один. Связанные entrypoint-ы позволяют организовать разные сценарии загрузки (например, для разных страниц).

## 2. Output (Результат сборки)

**Output** — параметры конфигурации, определяющие как и куда будет собран финальный код. В Webpack используется свойство `output`, в Vite — `outDir`. Важно, что `publicPath`/`base` определяет базовый путь до ассетов, и на проде он может отличаться (например, если деплой ведется на CDN или S3).

## 3. Модуль и граф модулей

**Модуль** — независимая часть кода, экспортирующая собственный API. 

Граф модулей — вся взаимосвязь импортов внутри приложения. 
Инструменты: dpdm, skott (для поиска циклических импортов), madge (устарел).

## 4. Виртуальный модуль (Virtual Module)

**Виртуальный модуль** — модуль, физически не существующий на диске, но доступный как обычный import (`virtual:my-module`). Типично для Vite и иногда для Webpack. 

Применяется, например, для проброса переменных окружения из build-time в runtime.

## 5. Динамический импорт/глобальный импорт

Современные сборщики поддерживают массовый импорт через паттерн (`import.meta.glob` — Vite, `require.context` — Webpack, динамик import — esbuild). 

Актуален для динамической загрузки модулей по условиям работы приложения.

## 6. Бандл и чанк

**Бандл** — итоговый скомбинированный файл(-ы), который грузит браузер. Бандл может быть монолитным (single bundle) либо разбиваться на чанки (code splitting). 

**Чанк** — отдельный файл в составе билда, может быть синхронным (entry), асинхронным (отложенная загрузка), вручную выделенным (vendor chunk и т.п.).

## 7. Code splitting

**Code splitting** — стратегия, при которой код разделяется на части, чтобы грузить только необходимые компоненты/страницы по требованию (lazy load), повышая перформанс.

## 8. Tree shaking

**Tree shaking** — устранение неиспользуемого кода из финального бандла (мертвого кода). 

Осуществляется в Rollup, Webpack и Vite, поддерживает только ES-модули.

## 9. Ассет (Asset)

**Ассет** — любой не-JS ресурс, который попадает в итоговую сборку: изображения, шрифты, видео, аудио, json и т.п. Сборщик должен уметь обрабатывать ассеты как обычные модули.

## 10. Минификация и сжатие

- **Минификация** — удаление незначащих символов (пробелы, комменты и т.д.) без изменения работы кода (Terser, cssnano).

- **Сжатие** — применение алгоритмов уменьшения размера данных (gzip, brotli) на этапе продового деплоя/серва.

## 11. Хэширование

**Хэш** — часть имени чанка или файла сборки, генерируется по содержимому. Меняется только если изменён файл. Обеспечивает валидное кэширование и обновление только изменившихся ассетов/чанков.

## 12. Плагины и лоадеры

**Плагин** — расширяет возможности сборщика (изменение процесса сборки, доп.логика). **Лоадер** — (Webpack) преобразует файлы (css, scss, svg, ts, etc.)

## 13. Watch mode & Dev server

- **Watch-mode** — перезапускает сборку при изменениях в файлах.
- **DevServer** — development-сервер, который не только обеспечивает быструю пересборку, но и поддерживает HMR (hot module replacement).

## 14. Source map / devtool

Позволяют сопоставить минифицированный код в бандле с исходными файлами, упрощая отладку на проде. (devtool — webpack, sourcemap — vite).

## 15. Stats

**Stats/manifest** — json с метаинформацией о сборке (для анализа, SSR или кастомного загрузчика).

---

### Краткие определения по современным сборщикам

- **Webpack** — объединил JS, CSS, ассеты. Предельная гибкость, плагинность, широкий экосистемный охват.
- **Rollup** — идеален для библиотек, лучший tree shaking. Легкий конфиг, поддержка форматов (cjs/esm/umd).
- **Vite** — быстрый dev-сервер, no-bundle подход (ESM, esbuild), rollup в проде. Отличный DX.
- **Esbuild** — скорость>всё, минимум расширяемости.

---

# Вопросы для собеседований (по терминам сборки)

## 1. Основные понятия:

- Чем отличается entrypoint от output?
- Зачем нужен граф модулей, какие инструменты его строят?
- Что такое виртуальный модуль?
- Как работают dynamic imports и зачем они нужны?
- Объясни разницу между бандлом и чанком
- Что такое code splitting и когда он применяется?
- Что такое tree shaking и в чем ограничения?
- Как сборщик работает с ассетами?
- Какова разница между минификацией и сжатием?
- Что такое hash в сборке?
- Что такое лоадер? Чем он отличается от плагина?
- Как работает watch-mode и зачем нужен dev-server?
- Для чего нужны sourcemaps/devtools?
- Как использовать stats/manifest?

## 2. Инструменты и практика:

- Как в Vite подключить alias?
- Как реализуется code splitting на Webpack и Vite?
- Как найти и устранить циклические импорты?
- Как подменить publicPath в зависимости от среды?
- Пример настройки хэшированного имени чанка в Webpack
- Пример конфигурирования минификации в Vite/Rollup
- Как анализировать граф модулей в реальном проекте?
- Как настроить watch для специфических директорий?

## 3. Современные тренды:

- Почему Webpack уступает позиции Vite и esbuild?
- Когда лучше выбрать Rollup/Esbuild?
- Как tree shaking зависит от формата модулей?
- Какие стандарты asset-обработки поддерживаются большинством сборщиков?
- Как избежать проблем caching при деплое на CDN?

