---
title: 
draft: true
tags: 
info:
---
### Новые возможности (экспериментальные)

##### Import Assertions

```javascript
// JSON модули
import config from './config.json' with { type: 'json' };

// CSS модули
import styles from './styles.css' with { type: 'css' };
```

##### Lazy initialization

```javascript
// Предложение для отложенной инициализации
import { feature } from './lib' with { lazyInit: true };
```

### Практические рекомендации

1. Выбор модульной системы

```javascript
// Для новых проектов - ESM
export const myFunction = () => {};

// Для библиотек - поддержка обеих систем
// package.json
{
    "main": "dist/index.cjs",
    "module": "dist/index.js",
    "exports": {
        ".": {
            "import": "./dist/index.js",
            "require": "./dist/index.cjs"
        }
    }
}
```

2. Миграция с CJS на ESM

```javascript
// Постепенная миграция
// 1. Изменить расширения на .mjs
// 2. Обновить package.json
// 3. Заменить require на import
// 4. Обновить экспорты

// Было
const fs = require('fs');
module.exports = { readFile: fs.readFile };

// Стало
import { readFile } from 'fs';
export { readFile };
```

3. Обработка Side Effects

```javascript
// package.json
{
    "sideEffects": false, // Нет побочных эффектов
    "sideEffects": ["./src/polyfills.js"] // Только в указанных файлах
}
```

Эволюция модульных систем в JavaScript показывает путь от простых паттернов к стандартизованным решениям:

1. **IIFE** — решил проблему области видимости
2. **AMD** — добавил асинхронную загрузку в браузере
3. **CommonJS** — стандартизовал модули для Node.js
4. **UMD** — обеспечил совместимость
5. **ESM** — стал нативной частью языка

Современные проекты должны использовать ESM как основу, обеспечивая совместимость с CommonJS для переходного периода. Понимание всех систем критично для работы с legacy кодом и библиотеками.

Дополнительные темы для изучения
- Module Federation в Webpack 5
- HTTP/2 и его влияние на стратегию загрузки модулей
- Web Assembly модули
- Streaming imports
