---
uid: zijK77DygK5r9Bkz1VLmR
title: "Что такое Eventloop, очередь задач, микрозадача и макрозадача?"
tags:
  - "#JavaScript"
  - "#EventLoop"
  - "#CallStack"
  - "#microtask"
  - "#macrotask"
info:
  - >-
    [[062 Событийный цикл. Микрозадачи и макрозадачи|Событийный цикл?
    Микрозадачи и макрозадачи]]
  - >-
    [[071 Объяснение работы EventLoop в JavaScript|Объяснение работы EventLoop в
    JavaScript]]
  - "[[070 Асинхронщина в JS под капотом|Асинхронщина в JS под капотом]]"
  - "https://habr.com/ru/post/461401/"
  - "https://habr.com/ru/articles/762618/"
  - "https://www.youtube.com/watch?v=tZXdWzWyp-s"
draft: false
technology: JSCore
specialty: Frontend
tools: []
order: 201
access: free
created_at: "2025-01-08T02:12:05+05:00"
updated_at: "2026-01-18T15:03:38.095Z"
---

##### Что такое цикл событий (event loop) и как он работает?

JavaScript является однопоточным языком программирования _(движок JS в 1 единицу времени может выполнять всего 1 операцию, для этого выделяется стек)_. В стеке хранятся фреймы - это локальные аргументы и переменные, которые хранятся в функции.

Список событий, которые должны обрабатываться формируют очередь событий. Когда стек освобождается движок может обработать любое событие из этой очереди.

Координирование этого процесса и происходит в `EventLoop`.

**`EventLoop`** - это механизм, используемый браузером или Node.js для управления асинхронным кодом. Он позволяет синхронизировать callstack и очередь задач.

1.  Выбрать и исполнить старейшую синхронную задачу.
2.  Исполнить все *микрозадачи*:
    - Пока очередь микрозадач пуста: - выбрать из очереди и исполнить старейшую микрозадачу
3.  Отрисовать изменения страницы (`requestAnimationFrame`), если они есть.
4.  Если очередь макрозадач пуста – подождать, пока появится макрозадача.
5.  Перейти к шагу 1.

![[Pasted image 20230218194535.png]]

На основе этой схемы строится вся работа Event Loop.

Если у кого-то из заказчиков не оказалось задач, то Event Loop просто идет к следующему. И, наоборот, если у заказчика задачи занимают много времени, то остальные заказчики будут ждать своей очереди. А если задачи от какого-то заказчика оказались бесконечными, то CallStack переполняется, и браузер начинает ругаться:

![[Pasted image 20230218195348.png]]

\_Рисунок 2 - Страница не отвечает

_Если где-то произойдёт ошибка, то отказ пропустит обработчики на выполнение и долетит до ближайшего обработчика отказа, после чего цепочка продолжит работать в штатном режиме._

```js
console.log("Start"); // Синхронный код, выполняется первым

// Микрозадача (Microtask)
queueMicrotask(() => {
  console.log("Inside microtask"); // Выполняется после синхронного кода, но перед макрозадачами
});

// Макрозадача (Macrotask)
setTimeout(() => {
  console.log("Inside macrotask"); // Выполняется после всех микрозадач
});

console.log("End"); // Синхронный код, выполняется вторым

/*
Ожидаемый результат выполнения:
1. Start
2. End
3. Inside microtask
4. Inside macrotask
*/
```

Ссылка: **[Иллюстрация работы событийного цикла](https://www.jsv9000.app/)**

##### Разница между микро- и макрозадачами в event loop?

###### **Микрозадачи (`microtask`)**

Асинхронные задачи требуют правильного управления. Для этого стандарт предусматривает внутреннюю очередь `PromiseJobs`, более известную как **очередь-микрозадач** (microtask queue)».

Микрозадачи - это задачи, которые добавляются в очередь микрозадач, после того как стек вызовов стал пуст, но до того, как будут выполнены макрозадачи.

Микрозадачи приходят только из кода. Обычно они создаются promise : выполнение обработчика `.then/catch/finally` становится микрозадачей. Микрозадачи также используются «под капотом» `await`, т.к. это форма обработки промиса.

Микрозадачи включают в себя:

- обработчики промисов.
- обработчики notationObserver.
- функции добавленные с помощью queueMicrotask.

**Расскажите о `queueMicrotask`**

![[Pasted image 20230723140208.png|]]

\_Рисунок 3 - Иллюстрация вызова queueMicrotask

**`queueMicrotask`** - это JavaScript метод, который используется для добавления переданной в неё функции в очередь микрозадач, внутри EventLoop.

###### **Макрозадачи (`macrotask`)**

Макрозадачи - это задачи, которые добавляются в очередь и добавляются после того как очередь задач пуста.

Задачи из очереди исполняются по правилу «первым пришёл – первым ушёл». Когда браузер заканчивает выполнение скрипта, он обрабатывает событие `mousemove`, затем выполняет обработчик, заданный `setTimeout`, и так далее.

Макрозадачи включают в себя:

- элементы пользовательского ввода;
- таймеры;
- загрузка и ресурсов
- и другие асинхронные задачи.

##### Решение задач на асинхронность

Рассмотрим примеры:

```js
Promise.resolve()
  .then(() => {
    return Promise.reject(`O_o`);
  })
  .then(() => {
    // Все обработчики будут не выполнены
  })
  .catch((error) => {
    console.log(error); // `O_o`
  })
  .then(() => {
    // Продолжаем выполнять цепочку
  });
```

_Возвращать значение можно и внутри catch, оно будет точно также обработано в цепочке._

```js
Promise.reject("O_o")
  .catch((error) => {
    console.log(error); // O_o
    return "^_^";
  })
  .then((value) => {
    console.log(value); // ^_^
  });
```

Важно понимать, что обработка ошибок работает только тогда, когда цепочка непрерывна. Если опустить `return` и создать обещание, установленное на отказ, то последующий `catch` не сможет его обработать.

```js
Promise.resolve()
  .then(() => {
    Promise.reject("O_o");
  })
  .catch(() => {
    // Будет пропушено
  });
```

---

[[003 JSCore|Назад]]
