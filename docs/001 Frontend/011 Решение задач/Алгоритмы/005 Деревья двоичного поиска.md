---
title: Деревья двоичного поиска
draft: true
tags:
  - algorithm
  - tree
info:
---

Бинарное дерево - это дерево, каждый узел которого имеет не более двух дочерних элементов. Дерево двоичного поиска (BST-Binary-Seacrh-Tree) - это бинарное дерево, элементы которого расположены в определенном порядке. В каждом BST все значения (то есть ключи) в левом поддереве имеют меньшие значения по сравнению с правым поддеревом.

```
ЗДЕСЬ ДОЛЖНО БЫТЬ ИЗОБРАЖЕНИЕ
```

#### Вставка узла

```js
function insertNode(root, value) {
    const newNode = { value, left: null, right: null };
    
    if (!root) return newNode; // Если дерево пустое
    
    let current = root;
    
    while (true) {
        if (value === current.value) break; // Игнорируем дубликаты
        if (value < current.value) {
            if (!current.left) {
                current.left = newNode;
                break;
            }
            current = current.left;
        } else {
            if (!current.right) {
                current.right = newNode;
                break;
            }
            current = current.right;
        }
    }
    return root;
}

// Пример использования:
let tree = null;
tree = insertNode(tree, 5);
tree = insertNode(tree, 3);
tree = insertNode(tree, 7);
console.log(tree); // Структура дерева
```

#### Удаление вершины

Каждая вершина в BST может иметь максимум две дочерние вершины (левую и правую). Все вершины левого поддерева содержат ключи меньшие, чем ключ корневой вершины. Оба поддерева каждой вершины тоже являются деревьями двоичного поиска, то есть также обладают первыми двумя свойствами.

Удаление узла в дереве с сохранением свойства дерева бинарного поиска.

При удалении вершины необходимо учитывать следующие случаи:
* Случай 1: удаляемая вершина является терминальной вершиной.
* Случай 2: удаляемая вершина имеет одну дочернюю вершину.
* Случай 3: удаляемая вершина имеет обе дочерние вершины.

```js
function deleteNode(root, value) {
    if (!root) return null;
    
    if (value < root.value) {
        root.left = deleteNode(root.left, value);
    } else if (value > root.value) {
        root.right = deleteNode(root.right, value);
    } else {
        // Узел найден
        if (!root.left) return root.right;
        if (!root.right) return root.left;
        
        // Находим минимальный узел в правом поддереве
        let minNode = root.right;
        
        while (minNode.left) minNode = minNode.left;
        
        // Заменяем значение и удаляем минимальный узел
        root.value = minNode.value;
        root.right = deleteNode(root.right, minNode.value);
    }
    return root;
}

// Пример использования:
tree = deleteNode(tree, 3);
console.log(tree); // Дерево без узла 3
```
#### Наименьший общий предок в BST

Свойство дерева бинарного поиска может быть использовано для нахождения наименьшего предка любых двух вершин.

```js
function findLCA(root, value1, value2) {
    let current = root;
    
    while (current) {
        if (value1 < current.value && value2 < current.value) {
            current = current.left;
        } else if (value1 > current.value && value2 > current.value) {
            current = current.right;
        } else {
            return current; // Найден LCA
        }
    }
    return null;
}

// Пример использования:
const lcaNode = findLCA(tree, 2, 4);
console.log("LCA:", lcaNode?.value); // 5 (после удаления 3)
```

___

[[Алгоритмы|Назад]]