---
title: σ-Большое
draft: true
tags:
  - algorithm
  - σ-Большое
info:
---
 
Обозначение `σ-Большое` по своей сути является математическим обозначением, используемым для сравнения скорости сходимости функции (скорость, с которой функция приближается к своему пределу).

Такие понятия, как `σ-Большое`, помогают сравнивать и классифицировать функции по скорости их сходимости (но данный способ не является точным). Для более точной оценки применяют асимптотический анализ.

При сравнении производительности алгоритмов нас интересует количество операций, которые выполняет алгоритм. Это называется вычислительной сложностью.

При подсчете операций обычно рассматривается худший случай: например, если у нас есть цикл, который может выполняться не более n раз и содержит 5 операций, то общее количество операций будет равно 5n. Можно также рассматривать и среднюю сложность.

Небольшое замечание: `быстрый алгоритм` - это тот, который выполняет мало операций, поэтому если количество операций возрастает до бесконечности быстрее, то алгоритм работает медленнее: σ(n) лучше, чем σ(n^2).

Иногда нас интересует пространственная сложность нашего алгоритма. Для этого мы считаем количество байт в памяти, занимаемых алгоритмом, как функцию от размера входных данных и аналогично используем σ-Большое.

### Простой цикл `σ(n)`

Приведем пример работы простого цикла:

```js
// Пример цикла с линейной сложностью O(n)
function calculateSum(n) {
    let sum = 0; // 1 операция (инициализация)
    
    // Цикл выполняется n раз → O(n)
    for (let i = 1; i <= n; i++) { 
        sum += i;  // 2 операции на каждой итерации: сложение + присваивание
        console.log(`Текущая сумма: ${sum}`); // 1 операция (вывод)
    }
    
    return sum;
}

// Запуск цикла для n = 5
console.log("Итоговая сумма:", calculateSum([1, 2, 3, 4, 5]));
```

`Входной размер` - это размер массива, который задан в переменной n.

Сложность показывает, как алгоритм масштабируется с размером входных данных, но это не единственный аспект производительности.

### Вложенный цикл `σ(n^2)`

Рассмотрим функцию, которая проверяет наличие дубликатов в массиве, беря каждый элемент, а затем выполняя итерацию по всему массиву, чтобы проверить, встречается ли еще в нем этот элемент:

```js
// Пример вложенного цикла с квадратичной сложностью O(n^2)
function hasDuplicates(arr) {
    for (let i = 0; i < arr.length; i++) { // Внешний цикл O(n)
        for (let j = 0; j < arr.length; j++) { // Внутренний цикл O(n)
            if (i !== j && arr[i] === arr[j]) {
                return true; // Найден дубликат
            }
        }
    }
    return false; // Дубликатов нет
}

```

Внутренний цикл выполняет на каждой итерации количество операций, постоянное по отношению к n. Внешний цикл также выполняет несколько постоянных операций и запускает внутренний цикл n раз. Сам внешний цикл выполняется n-раз. Таким образом, операции внутри внутреннего цикла выполняются раз, операции во внешнем цикле выполнятся n раз, а присваивание i выполняется один раз. Таким образом, сложность будет иметь вид an^2 + bn + c, а поскольку наибольший член равен a^2 , то в обозначении `σ-Большое` будет равно σ(n^2).

Однако, как можно заметить, мы можем улучшить алгоритм, избежав многократного выполнения одни и тех же сравнений. Во внутреннем цикле мы можем начать с i+1-й элемент, тк все элементы до него уже будут проверены на соответствие всем элементам массива, включая элемент с индексом i+1. Это позволяет отказаться от проверки i === j.

```js
// Пример вложенного цикла с квадратичной сложностью O(n^2)
function hasDuplicates(arr) {
    for (let i = 0; i < arr.length; i++) { // Внешний цикл O(n)
        for (let j = i + 1; j < arr.length; j++) { // Внутренний цикл O(n)
            if (arr[i] === arr[j]) {
                return true; // Найден дубликат
            }
        }
    }
    return false; // Дубликатов нет
}

```

Очевидно, что во втором варианте выполняется меньше операций, а значит, он более эффективен. Мы явным образом понизили вычислительную сложность практически в 2 раза, но все еще остались в том же классе сложности с тем же значением `σ-Большое`. Чтобы понизить сложность до более низкого класса, требуется разделить количество операций на величину, стремящуюся к бесконечности с ростом n.

### Алгоритмы с вычислительной сложностью `σ(log(n))` 

Алгоритм с вычислительной сложностью `O(log(n))` обычно встречается в задачах, где количество рассматриваемых элементов уменьшается вдвое на каждом шаге. Один из классических примеров — **бинарный поиск**.

```js
function binarySearch(arr, target) {
    let left = 0;
    let right = arr.length - 1;

    while (left <= right) {
        let mid = Math.floor((left + right) / 2);

        if (arr[mid] === target) {
            return mid; // Найден элемент
        } else if (arr[mid] < target) {
            left = mid + 1; // Ищем в правой половине
        } else {
            right = mid - 1; // Ищем в левой половине
        }
    }

    return -1; // Элемент не найден
}

const sortedArray = [1, 3, 5, 7, 9, 11, 13, 15];
console.log(binarySearch(sortedArray, 7)); // Выведет 3 (индекс элемента)
console.log(binarySearch(sortedArray, 8)); // Выведет -1 (элемент не найден)
```

Рассмотрим следующую задачу:

```js
/**
Пусть L - отсортированный список, содержащий n знаковых целых чисел (n достаточно велико), например [-5, -2, -1, 0, 1, 2, 4] (здесь n имеет значение 7). 

Известно, что L содержит целое число 0. Необходимо определить индекс числа 0.
*/

const array = [-5, -2, -1, 0, 1, 2, 4]

const findNullIndex = (array) => {
	// Ваш код здесь
}
```

Как решить эту задачу оптимальным способом?

___

[[Алгоритмы|Назад]]