---
title: Кастомизация комплексных компонентов UI Kit
draft: false
tags:
  - UIKit
  - инкапсуляция
info:
  - https://habr.com/ru/articles/743488/
---
UI Kit включает не только атомарные компоненты, такие как кнопки, поля ввода, селекторы, но и комплексные – вроде наборов графиков, фильтров, панелей и тд.

Поскольку проект должен содержать весь возможный набор компонентов, можно сформулировать к нему ряд требований:

1. **Полная или частичная кастомизация компонентов**. Интерфейсы могут быть использованы на специфичном оборудовании, а значит, должна быть возможность отходить от общей дизайн-системы. Например, сократить отступы, чтобы на экран поместилось больше информации, скорректировать палитру цветов для отдельных компонентов, так как на целевом оборудовании могут быть проблемы с цветопередачей и т. п.
2. **Слабая связанность компонентов или полное ее отсутствие** с целью оптимизации размера загружаемого бандла.
3. **Инкапсуляция компонента**. Разработчик не должен вникать в реализацию компонента, чтобы внести какие-либо изменения. Компонент должен предоставлять все необходимые интерфейсы, которые должны быть задокументированы.

Пункты 1 и 3 оказались взаимосвязаны, и мы столкнулись с проблемой для компонентов со сложной структурой – либо не даем в достаточной мере стилизовать компонент, либо нарушаем инкапсуляцию.

Атомарные компоненты стилизуются очень просто. Например, данный компонент кнопки не имеет дочерних элементов, достаточно добавить значение атрибута `className` к текущему списку классов тега `button` и можно стилизовать компонент как душе угодно из родительского компонента.

```jsx

function Button({ className }) {	
	return (    
		<button     
			className={joinClassNames('button', className)} ...    >      
			...    
		</button>  
	);
}
```

А вот с комплексными компонентами не все так прозаично, здесь порой требуется стилизовать элемент, к `className` которого нет прямого доступа. 
А так как подход из примера выше должен остаться, поскольку корневой элемент так или иначе стилизовать приходится, то атрибут `className` уже задействован.

Рассмотрим фрагмент компонента переключателя:

`Switcher.jsx`

```JSX
function Switcher(className) {	
	...	
	
	return (		
		<label className={joinClassNames('switcher', className)}>			
			<input type="checkbox" className="switcher__input" ...>			
			<div className="switcher__marker" />		
		<label>	
	);
}
```

```CSS
.switcher {	
	font-size: 16px;
}

.switcher__input {	
	clip: rect(1px, 1px, 1px, 1px);	
	clip-path: inset(50%);	
	height: 1px;	
	margin: -1px;	
	overflow: hidden;	
	padding: 0;	
	position: absolute;	
	width: 1px;
}

.switcher__marker {	
	background-color: #eee;	
	border-radius: 0.625em;	
	height: 1.125em;	
	position: relative;	
	width: 2em;
}

.switcher__marker::before {	
	background-color: white;	
	border-radius: 50%;	
	content: '';	
	height: calc(1.125em - 0.25em);	
	left: 0.125em;	
	position: absolute;	
	top: 0.125em;	
	width: calc(1.125em - 0.25em);
}

:checked + .switcher__marker {	
	background-color: #ae4;
}
	
:checked + .switcher__marker::before {	
	left: 100%;	transform: translateX(-1em);
}
```

Как и в первом примере, для корневого элемента применяется className из пропсов. Это позволит настраивать отображение компонента в связке с соседями и родителем: задать отступы, позиционирование, размер шрифта и т. д. А вот сам переключатель уже стилизовать просто так не получится.

___

[[310 UI Kit|Назад]]
