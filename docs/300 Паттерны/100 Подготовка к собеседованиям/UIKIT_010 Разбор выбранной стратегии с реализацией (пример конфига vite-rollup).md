---
title: Как выглядит разбор выбранной стратегии с реальной реализацией?
draft: false
tags:
  - dependencies
  - bundle
  - devDependencies
  - peerDependencies
  - HeadlessUI
  - vite
  - webpack
  - UIKit
info:
---
Разберем, как сделать свой UI-кит, на конкретном примере. 

Рассмотрим один из проектов. Это SPA-приложение, в котором есть личный кабинет пользователя, то есть проблем с долгой загрузкой быть не должно. Из всех перечисленных выше вариантов здесь подходит вариант со сборкой стилей в единый бандл. По стратегии, проще получить один раз все стили, чтобы не подгружать чанки в дальнейшем.

Старт разработки начинаем достаточно просто. Идем на сайт Vite и берем команду для инициализации пустого проекта на React + TypeScript. Если необходимы другие стартеры, то можете посмотреть в [документации](https://github.com/vitejs/vite/tree/main/packages/create-vite), как это сделать. 

```bash
yarn create vite ui-kit --template react-ts
```

После выполнения команды мы получим практически пустой проект-стартер, с которым и будем работать.

Первым делом я начинаю с конфигурации package.json для ограничения версий используемых технологий, а также с настройки пакета как библиотеки.

```json
"name": "@projectName/ui-kit",
"engines": { 
	"node": ">=18.18.2", 
	"yarn": ">=1.22.21"
},
```

В качестве имени "name" проекта мы используем пространство имен "name" space, в нашем случае — "@projectName". Это полезно, если собираетесь поднимать свой собственный реестр пакетов Package registry, из которого затем и устанавливать его. 

Блок "engines" я тоже рекомендую указывать, чтобы закрепить версии пакетного менеджера и ноды, и гарантировать правильную работу. Далее, если CI/CD будете делать не вы сами, то это в том числе поможет избежать путаницы. Это не обязательно, но лучше один раз указать.

Из базовых настроек всё. Дальше специфические для библиотеки.

```json
// зависимости, которые попадают в конечный bundle
"dependencies": ...

// зависимости, которые нужны только для разработки и не требуются в конечном bundle
"devDependencies": ...

// зависимости, которые должны быть установлены у пользователя в его проекте, для использования Вашей библиотеки.
"peerDependencies": { 
	"react": "^18.2.0", 
	"react-dom": "^18.2.0"
},

// папка, где будет лежать билд
"files": [ "dist"],

// файл, который будет содержать набор компонентов для импорта
"main": "./dist/index.js",

// типы для компонентов
"types": "./dist/index.d.ts",

// блок, в котором указываем необходимые файлы для экспорта — в дальнейшем они будут доступны для импорта в нашем приложении
"exports": { 
	"./dist/style.css": "./dist/style.css", 
	".": {   
		"import": "./dist/index.js",   
		"types": "./dist/index.d.ts" 
	}
},

// параметр, необходимый для возможности сброса лишних зависимостей или, как принято говорить, "​​tree shaking" при использовании в основном проекте в качестве сборщика WebPack.
"sideEffects": [ "**/*.css"]
```

Мы разобрались с первым пунктом. Дальше нам ничего не мешает написать свои компоненты и собрать их в бандл. Этого уже будет достаточно для работы с Headless UI Kit. Но если нам нужны стили для компонентов, придется добавить еще несколько строк в конфигурацию Vite. Для начала установим необходимые зависимости:

```bash
yarn add rollup vite-plugin-dts glob
```

После этого заменим содержимое **"vite.config.ts"** на следующее, после чего разберем его по пунктам:

```JSX
import { defineConfig } from 'vite'
import dts from "vite-plugin-dts";
import { extname, relative, resolve } from 'path'
import { fileURLToPath } from 'node:url'
import { glob } from 'glob'
import react from "@vitejs/plugin-react";

// список путей к нашим компонентам, который мы будем использовать далее для сборки. Он позволяет нам повторить структуру папки с компонентами в папке Dist нашей библиотеки.
const entries = Object.fromEntries(glob.sync('src/components/**/*.{ts,tsx}')
	.map(file => [  
		relative('src/components', file.slice(0, file.length - extname(file).length)),    
	fileURLToPath(new URL(file, import.meta.url))  
	]))
	

// для сборки разного формата мы будем использовать настройки, и часть из них повторяется, так что выносим для более удобной управляемости.
const outputBase = { 
	globals: {   
		"react": "React",   
		"react-dom": "ReactDOM",   
		"react/jsx-runtime": "jsxRuntime",   
		"classnames/bind": "cn",   
		"classnames": "classnames" 
	}
}
	
	
// https://vitejs.dev/config/export 

default defineConfig({ 
	// плагины, которые мы подключили для сборки. У нас в базе их два: сам реакт — первый, второй — для генерации типов.
	plugins: [   
		react(),   
		dts({ insertTypesEntry: true }), 
	], 
	// позволяет определять переменные, с которыми мы можем работать при сборке, так как, возможно, возникнет необходимость в использовании переменных окружения. Объявим их в этом блоке.
	define: {   
		'process.env': {} 
	}, 
	// один из самых интересных разделов конфига, про который стоит поговорить отдельно, но и в нем есть и очевидные вещи.
	build: {   
		// отвечает за очистку директории для сборки.
		emptyOutDir: true,   
		// отвечает за имя папки для сборки.
		outDir: "./dist",   
		// позволяет настроить режим сборки в качестве библиотеки.
		lib: {     
			// имя библиотеки.
			name: "uikit",     
			// имя входного файла для сборки.
			entry: resolve(__dirname, "src/components/index.ts"),   
		},
		// отвечает за возможность сборки, которая будет ориентирована для SSR  
		ssr: true,   
		// отвечает за необходимость копирования папки Public в сборку, например если нам нужны какие-то картинки.
		copyPublicDir: false,   
		]

// https://vitejs.dev/config/build-options.html#build-rollupoptions   

// отвечает за настройку сборщика [rollup](https://rollupjs.org/).
rollupOptions: {  
	// позволяет определить внешний зависимости для библиотеки.
	external: ["react", "react-dom", "styled-components", "classnames"],
	// позволяет указать файл или список файлов для сборки библиотеки. Если указываем список файлов, то в папке Dist будет повторяющаяся структура папки с компонентами. Мы именно для этого ранее сформировали массив с именами файлов и определили его как **entries**.     
	input: entries, 
	// массив настроек форматов для конечного бандла. В нашем случае мы используем два формата: это CJS и ESM. Более детально про форматы и их настройки можно посмотреть в [документации](https://rollupjs.org/configuration-options/).    
	output:     
		[       
			{         
				...outputBase,         
				exports: "named",         
				format: "cjs",         
				esModule: true       
			},       
			{         
				...outputBase,         
				exports: "named",         
				format: "esm",         
				interop: "esModule",       
			},   
		],     
		// позволяет подключать плагины для сборщика, в нашем случае мы ничего не используем.
		plugins: [],   
	}},
})
```

Итак, на данный момент мы готовы написать наши компоненты и собрать из них библиотеку. На самом деле есть куча подходов к написанию компонентов, поэтому выбирайте тот, который вам нравится. Мы выбрали **module.css + clsx + sass** для более гибкого написания и применения стилей.

По структуре папок мы сделали всё достаточно просто, добавили components, где дальше уже в плоской структуре лежат наши компоненты.

Важно, что в корне папки с компонентами нам необходимо добавить файл `index.ts`, в который мы будем добавлять наши компоненты, а он в свою очередь будет также являться точкой входа для сборщика.

Небольшой пример содержимого данного файла:

```jsx
import { Checkbox } from "./checkbox/checkbox";
import { Form } from "./form/form";
import { Radio } from "./radio/radio";
import Input from "./input/input";
import SearchInput from "./search-input/search-input";
import PasswordInput from "./password-input/password-input";


export { Checkbox, Form, Radio, Input, SearchInput, PasswordInput,};
```

Давайте посмотрим на пример блока **"scripts"** в нашем проекте:

```json
"scripts": { 
	// режим для разработки
	"dev": "vite", 
	"build": "tsc && vite build", 
	"lint": "eslint . --ext ts,tsx --report-unused-disable-directives --max-warnings 0", 
	"format": "prettier --write ./src", 
	"prepare": "husky", 
	"bump": "npm version patch -m \"UI Kit version updated to v%s\"", 
	"bump:minor": "npm version minor -m \"UI Kit version updated to v%s\"", 
	"bump:major": "npm version major -m \"UI Kit version updated to v%s\""
},
```

Чаще всего мы будем использовать две команды. 

Первая — **yarn bump**, которая через NPM изменяет версию нашей библиотеки. Вторая — **build**, которая собирает бандл библиотеки.

Если имеем дело с реестром пакетов, настраиваем в CI/CD, но не забываем и про **husky,** который тоже должен сделать билд, чтобы мы не запушили нерабочую версию.

Также было бы неплохо использовать линтеры и форматеры. Кроме того, мы можем накручивать не только фикс-версию, но и минорную и мажорную версию "bump:minor" и "bump:major" соответственно.

Пример стартера UI-кита для React/Next JS можно найти [в репозитории](https://github.com/skaziweb/react-ts-ui-kit-starter).

___

[[310 UI Kit|Назад]]
